{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from '../../interfaces/IPoolAddressesProvider.sol';\nimport {IPool} from '../../interfaces/IPool.sol';\n\n/**\n * @title IFlashLoanSimpleReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanSimpleReceiver {\n  /**\n   * @notice Executes an operation after receiving the flash-borrowed asset\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\n   *      enough funds to repay and has approved the Pool to pull the total amount\n   * @param asset The address of the flash-borrowed asset\n   * @param amount The amount of the flash-borrowed asset\n   * @param premium The fee of the flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @param params The byte-encoded params passed when initiating the flashloan\n   * @return True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    address asset,\n    uint256 amount,\n    uint256 premium,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  function POOL() external view returns (IPool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@prb/math/src/Core.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n/// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\nerror PRBMath__MulDiv18Overflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\nerror PRBMath__MulDivOverflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\nerror PRBMath__MulDivSignedOverflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev How many trailing decimals can be represented.\nuint256 constant UNIT = 1e18;\n\n/// @dev Largest power of two that is a divisor of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/// @dev The `UNIT` number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\n/// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each of the steps in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/paulrberg/f932f8693f2733e30c4d479e8e980948\n///\n/// A list of the Yul instructions used below:\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as an uint256.\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Requirements:\n/// - The denominator cannot be zero.\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The multiplicand as an uint256.\n/// @param y The multiplier as an uint256.\n/// @param denominator The divisor as an uint256.\n/// @return result The result as an uint256.\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath__MulDivOverflow(x, y, denominator);\n    }\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n    unchecked {\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by lpotdod.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * lpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates floor(x*y÷1e18) with full precision.\n///\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\n/// instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n///\n/// Requirements:\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\n///     1. x * y = type(uint256).max * UNIT\n///     2. (x * y) % UNIT >= UNIT / 2\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath__MulDiv18Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly {\n        remainder := mulmod(x, y, UNIT)\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    assembly {\n        result := mul(\n            or(\n                div(sub(prod0, remainder), UNIT_LPOTD),\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n            ),\n            UNIT_INVERSE\n        )\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\n///\n/// Requirements:\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit within int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath__MulDivSignedInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 absX;\n    uint256 absY;\n    uint256 absD;\n    unchecked {\n        absX = x < 0 ? uint256(-x) : uint256(x);\n        absY = y < 0 ? uint256(-y) : uint256(y);\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n    uint256 rAbs = mulDiv(absX, absY, absD);\n    if (rAbs > uint256(type(int256).max)) {\n        revert PRBMath__MulDivSignedOverflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly {\n        // This works thanks to two's complement.\n        // \"sgt\" stands for \"signed greater than\" and \"sub(0,1)\" is max uint256.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers.\n/// See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // We're doing two things at the same time:\n        //\n        //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n        //      rather than 192.\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n        //\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n/// Credits to OpenZeppelin for the explanations in code comments below.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as an uint256.\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$ and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // Round down the result in case x is not a perfect square.\n        uint256 roundedDownResult = x / result;\n        if (result >= roundedDownResult) {\n            result = roundedDownResult;\n        }\n    }\n}\n"
    },
    "@prb/math/src/SD59x18.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \"./Core.sol\";\n\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int256.\ntype SD59x18 is int256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Emitted when taking the absolute value of `MIN_SD59x18`.\nerror PRBMathSD59x18__AbsMinSD59x18();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(SD59x18 x);\n\n/// @notice Emitted when dividing two numbers and one of them is `MIN_SD59x18`.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(SD59x18 x);\n\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(SD59x18 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(SD59x18 x);\n\n/// @notice Emitted when taking the geometric mean of two numbers and their product is negative.\nerror PRBMathSD59x18__GmNegativeProduct(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the logarithm of a number less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(SD59x18 x);\n\n/// @notice Emitted when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when multiplying two numbers and the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when raising a number to a power and hte intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(SD59x18 x, uint256 y);\n\n/// @notice Emitted when taking the square root of a negative number.\nerror PRBMathSD59x18__SqrtNegativeInput(SD59x18 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(SD59x18 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__ToSD59x18Overflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__ToSD59x18Underflow(int256 x);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as an SD59x18 number.\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\n\n/// @dev Half the UNIT number.\nint256 constant uHALF_UNIT = 0.5e18;\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\n\n/// @dev log2(10) as an SD59x18 number.\nint256 constant uLOG2_10 = 3_321928094887362347;\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\n\n/// @dev log2(e) as an SD59x18 number.\nint256 constant uLOG2_E = 1_442695040888963407;\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an SD59x18 number can have.\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\n\n/// @dev The maximum whole value an SD59x18 number can have.\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\n\n/// @dev The minimum value an SD59x18 number can have.\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\n\n/// @dev The minimum whole value an SD59x18 number can have.\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\n\n/// @dev PI as an SD59x18 number.\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount which implies how many trailing decimals can be represented.\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\nint256 constant uUNIT = 1e18;\n\n/// @dev Zero as an SD59x18 number.\nSD59x18 constant ZERO = SD59x18.wrap(0);\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { abs, avg, ceil, div, exp, exp2, floor, frac, gm, inv, log10, log2, ln, mul, pow, powu, sqrt } for SD59x18 global;\n\n/// @notice Calculate the absolute value of x.\n///\n/// @dev Requirements:\n/// - x must be greater than `MIN_SD59x18`.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @param result The absolute value of x as an SD59x18 number.\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__AbsMinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y, rounding towards zero.\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    unchecked {\n        // This is equivalent to \"x / 2 +  y / 2\" but faster.\n        // This operation can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, we add 1 to the result, since shifting negative numbers to the right rounds\n            // down to infinity. The right part is equivalent to \"sum + (x % 2 == 1 || y % 2 == 1)\" but faster.\n            assembly {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // We need to add 1 if both x and y are odd to account for the double 0.5 remainder that is truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole SD59x18 number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to ceil.\n/// @param result The least number greater than or equal to x, as an SD59x18 number.\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert PRBMathSD59x18__CeilOverflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number. Rounds towards zero.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers. Works by computing the signs and the absolute values\n/// separately.\n///\n/// Requirements:\n/// - All from `Core/mulDiv`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator cannot be zero.\n/// - The result must fit within int256.\n///\n/// Caveats:\n/// - All from `Core/mulDiv`.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @param result The quotient as an SD59x18 number.\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__DivInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNIT)÷y. The resulting value must fit within int256.\n    uint256 resultAbs = mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__DivOverflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs don't have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n/// - x must be less than 133.084258667509499441.\n///\n/// Caveats:\n/// - All from `exp2`.\n/// - For any x less than -41.446531673892822322, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    // Without this check, the value passed to `exp2` would be less than -59.794705707972522261.\n    if (xInt < -41_446531673892822322) {\n        return ZERO;\n    }\n\n    // Without this check, the value passed to `exp2` would be greater than 192.\n    if (xInt >= 133_084258667509499441) {\n        revert PRBMathSD59x18__ExpInputTooBig(x);\n    }\n\n    unchecked {\n        // Do the fixed-point multiplication inline to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Requirements:\n/// - x must be 192 or less.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - For any x less than -59.794705707972522261, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n        if (xInt < -59_794705707972522261) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Do the fixed-point inversion $1/2^x$ inline to save gas. 1e36 is UNIT * UNIT.\n            result = wrap(1e36 / unwrap(exp2(wrap(-xInt))));\n        }\n    } else {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (xInt >= 192e18) {\n            revert PRBMathSD59x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to convert the result to int256 with no checks because the maximum input allowed in this function is 192.\n            result = wrap(int256(prbExp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole SD59x18 number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to floor.\n/// @param result The greatest integer less than or equal to x, as an SD59x18 number.\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert PRBMathSD59x18__FloorUnderflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @param result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit within `MAX_SD59x18`, lest it overflows.\n/// - x * y must not be negative, since this library does not handle complex numbers.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to \"xy / x != y\". Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert PRBMathSD59x18__GmOverflow(x, y);\n        }\n\n        // The product must not be negative, since this library does not handle complex numbers.\n        if (xyInt < 0) {\n            revert PRBMathSD59x18__GmNegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\n        // during multiplication. See the comments within the `prbSqrt` function.\n        uint256 resultUint = prbSqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates 1 / x, rounding toward zero.\n///\n/// @dev Requirements:\n/// - x cannot be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    // 1e36 is UNIT * UNIT.\n    result = wrap(1e36 / unwrap(x));\n}\n\n/// @notice Calculates the natural logarithm of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}$$.\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n    // can return is 195.205294292027477728.\n    result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x.\n///\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n/// logarithm based on the formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMathSD59x18__LogInputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the assembly mul operation, not the SD59x18 `mul`.\n    // prettier-ignore\n    assembly {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default {\n            result := uMAX_SD59x18\n        }\n    }\n\n    if (unwrap(result) == uMAX_SD59x18) {\n        unchecked {\n            // Do the fixed-point division inline to save gas.\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x.\n///\n/// @dev Based on the iterative approximation algorithm.\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Requirements:\n/// - x must be greater than zero.\n///\n/// Caveats:\n/// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt <= 0) {\n        revert PRBMathSD59x18__LogInputTooSmall(x);\n    }\n\n    unchecked {\n        // This works because of:\n        //\n        // $$\n        // log_2{x} = -log_2{\\frac{1}{x}}\n        // $$\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Do the fixed-point inversion inline to save gas. The numerator is UNIT * UNIT.\n            xInt = 1e36 / xInt;\n        }\n\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate $y = x * 2^(-n)$.\n        uint256 n = msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is maximum 255, UNIT is 1e18 and sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // This is $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is 1, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n        int256 DOUBLE_UNIT = 2e18;\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is $y^2 > 2$ and so in the range [2,4)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultInt = resultInt + delta;\n\n                // Corresponds to z/2 on Wikipedia.\n                y >>= 1;\n            }\n        }\n        resultInt *= sign;\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers and employs constant folding, i.e. the denominator\n/// is always 1e18.\n///\n/// Requirements:\n/// - All from `Core/mulDiv18`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - To understand how this works in detail, see the NatSpec comments in `Core/mulDivSigned`.\n///\n/// @param x The multiplicand as an SD59x18 number.\n/// @param y The multiplier as an SD59x18 number.\n/// @return result The product as an SD59x18 number.\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__MulInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    uint256 resultAbs = mulDiv18(xAbs, yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__MulOverflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Raises x to the power of y.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// Requirements:\n/// - All from `exp2`, `log2` and `mul`.\n/// - x cannot be zero.\n///\n/// Caveats:\n/// - All from `exp2`, `log2` and `mul`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x Number to raise to given power y, as an SD59x18 number.\n/// @param y Exponent to raise x to, as an SD59x18 number\n/// @return result x raised to power y, as an SD59x18 number.\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    if (xInt == 0) {\n        result = yInt == 0 ? UNIT : ZERO;\n    } else {\n        if (yInt == uUNIT) {\n            result = x;\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n}\n\n/// @notice Raises x (an SD59x18 number) to the power y (unsigned basic integer) using the famous algorithm\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n///\n/// Requirements:\n/// - All from `abs` and `Core/mulDiv18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - All from `Core/mulDiv18`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y The exponent as an uint256.\n/// @return result The result as an SD59x18 number.\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\n    uint256 xAbs = uint256(unwrap(abs(x)));\n\n    // Calculate the first iteration of the loop in advance.\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\n\n    // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n    uint256 yAux = y;\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n        xAbs = mulDiv18(xAbs, xAbs);\n\n        // Equivalent to \"y % 2 == 1\" but faster.\n        if (yAux & 1 > 0) {\n            resultAbs = mulDiv18(resultAbs, xAbs);\n        }\n    }\n\n    // The result must fit within `MAX_SD59x18`.\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__PowuOverflow(x, y);\n    }\n\n    unchecked {\n        // Is the base negative and the exponent an odd number?\n        int256 resultInt = int256(resultAbs);\n        bool isNegative = unwrap(x) < 0 && y & 1 == 1;\n        if (isNegative) {\n            resultInt = -resultInt;\n        }\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down. Only the positive root is returned.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Requirements:\n/// - x cannot be negative, since this library does not handle complex numbers.\n/// - x must be less than `MAX_SD59x18` divided by `UNIT`.\n///\n/// @param x The SD59x18 number for which to calculate the square root.\n/// @return result The result as an SD59x18 number.\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMathSD59x18__SqrtNegativeInput(x);\n    }\n    if (xInt > uMAX_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__SqrtOverflow(x);\n    }\n\n    unchecked {\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two SD59x18\n        // numbers together (in this case, the two numbers are both the square root).\n        uint256 resultUint = prbSqrt(uint256(xInt * uUNIT));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                            CONVERSION FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Converts an SD59x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\n/// @param x The SD59x18 number to convert.\n/// @return result The same number as a simple integer.\nfunction fromSD59x18(SD59x18 x) pure returns (int256 result) {\n    result = unwrap(x) / uUNIT;\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\nfunction sd(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\n/// @dev Alias for the \"sd\" function defined above.\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Converts a simple integer to SD59x18 by multiplying it by `UNIT`.\n///\n/// @dev Requirements:\n/// - x must be greater than or equal to `MIN_SD59x18` divided by `UNIT`.\n/// - x must be less than or equal to `MAX_SD59x18` divided by `UNIT`.\n///\n/// @param x The basic integer to convert.\n/// @param result The same number converted to SD59x18.\nfunction toSD59x18(int256 x) pure returns (SD59x18 result) {\n    if (x < uMIN_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__ToSD59x18Underflow(x);\n    }\n    if (x > uMAX_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__ToSD59x18Overflow(x);\n    }\n    unchecked {\n        result = wrap(x * uUNIT);\n    }\n}\n\n/// @notice Unwraps an SD59x18 number into the underlying signed integer.\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\nfunction wrap(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                        GLOBAL-SCOPED HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    add,\n    and,\n    eq,\n    gt,\n    gte,\n    isZero,\n    lshift,\n    lt,\n    lte,\n    mod,\n    neq,\n    or,\n    rshift,\n    sub,\n    uncheckedAdd,\n    uncheckedSub,\n    uncheckedUnary,\n    xor\n} for SD59x18 global;\n\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) + unwrap(y));\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) & bits);\n}\n\n/// @notice Implements the equal (=) operation in the SD59x18 type.\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) == unwrap(y);\n}\n\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) > unwrap(y);\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) >= unwrap(y);\n}\n\n/// @notice Implements a zero comparison check function in the SD59x18 type.\nfunction isZero(SD59x18 x) pure returns (bool result) {\n    result = unwrap(x) == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) < unwrap(y);\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) <= unwrap(y);\n}\n\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % unwrap(y));\n}\n\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) != unwrap(y);\n}\n\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) | unwrap(y));\n}\n\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) - unwrap(y));\n}\n\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) + unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) - unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(-unwrap(x));\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) ^ unwrap(y));\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                        FILE-SCOPED HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { uncheckedDiv, uncheckedMul } for SD59x18;\n\n/// @notice Implements the unchecked standard division operation in the SD59x18 type.\nfunction uncheckedDiv(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) / unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked standard multiplication operation in the SD59x18 type.\nfunction uncheckedMul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) * unwrap(y));\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/accounts/MarketAccounts.sol": {
      "content": "pragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\n\r\ncontract MarketAccounts is ERC721Enumerable {\r\n\r\n    uint256 public totalAccountsCreated;\r\n\r\n    event UpdatedTokenURI(string uri);\r\n    event AccountCreated(uint256 vaultID, address creator);\r\n\r\n    string public baseUri;\r\n\r\n    constructor(string memory name, string memory symbol, string memory _uri)\r\n    ERC721(name, symbol)\r\n    {\r\n        _setBaseURI(_uri);\r\n    }\r\n\r\n    function _baseURI() internal view override returns (string memory) {\r\n        string memory uri = baseUri;\r\n        return uri;\r\n    }\r\n\r\n    /// @param _uri is the url for the nft metadata\r\n    /// @notice updates the metadata\r\n    /// @dev it currently uses an ipfs json\r\n    function _setBaseURI(string memory _uri) internal {\r\n        baseUri = _uri;\r\n        emit UpdatedTokenURI(_uri);\r\n    }\r\n\r\n\r\n    /// @notice Creates a new vault and returns its id\r\n    /// @return id is the new vault's id\r\n    function _openAccount() internal returns (uint256) {\r\n        uint256 id = totalAccountsCreated;\r\n        totalAccountsCreated = totalAccountsCreated + 1;\r\n\r\n        _mint(msg.sender, id);\r\n        emit AccountCreated(id, msg.sender);\r\n        return id;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IMarket {\r\n    function deposit(uint256 accountID, uint256 amount) external;\r\n    function withdraw(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) external;\r\n    function borrow(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) external;\r\n    function repay(uint256 accountID, uint256 amount) external;\r\n    function liquidate(uint256 accountID, uint amountLiquidated) external returns(uint256);\r\n    function claimLiquidationRewards() external returns(uint256);\r\n    function collateralToken() external returns(IERC20);\r\n    function debtToken() external returns(IERC20);\r\n}"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n/// @dev Oracles should always return un the price in FTM with 18 decimals\r\ninterface IPriceOracle {\r\n    /// @dev This method returns a flashloan resistant price.\r\n    function getSafePrice(address token) external view returns (uint256 _amountOut);\r\n\r\n    /// @dev This method has no guarantee on the safety of the price returned. It should only be\r\n    //used if the price returned does not expose the caller contract to flashloan attacks.\r\n    function getCurrentPrice(address token) external view returns (uint256 _amountOut);\r\n\r\n    /// @dev This method returns a flashloan resistant price, but doesn't\r\n    //have the view modifier which makes it convenient to update\r\n    //a uniswap oracle which needs to maintain the TWAP regularly.\r\n    //You can use this function while doing other state changing tx and\r\n    //make the callers maintain the oracle.\r\n    function updateSafePrice(address token) external returns (uint256 _amountOut);\r\n}"
    },
    "contracts/interfaces/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPriceProvider {\r\n  function getSafePrice(address token) external view returns (uint256);\r\n\r\n  function getCurrentPrice(address token) external view returns (uint256);\r\n\r\n  function updateSafePrice(address token) external returns (uint256);\r\n\r\n  function BASE_TOKEN() external view returns (address);\r\n\r\n  function DECIMALS() external view returns (uint8);\r\n  \r\n}\r\n"
    },
    "contracts/interfaces/ISolidlyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface ISolidlyPair {\r\n    function stable() external view returns(bool);\r\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\r\n    function claimFees() external returns (uint, uint);\r\n    function tokens() external returns (address, address);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\r\n    function getAmountOut(uint, address) external view returns (uint);\r\n}"
    },
    "contracts/interfaces/ISolidlyPairFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISolidlyPairFactory {\r\n    function getFee(bool _stable) external returns(uint256);\r\n}\r\n\r\n"
    },
    "contracts/interfaces/ISolidlyRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface ISolidlyRouter {\r\n    \r\n    struct route {\r\n        address from;\r\n        address to;\r\n        bool stable;\r\n    }\r\n\r\n    function factory() external view returns(address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        route[] calldata routes,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts); \r\n}\r\n\r\n"
    },
    "contracts/interfaces/IZeroEx.sol": {
      "content": "// SPDX-License-Identifier:Apache-2.0\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IZeroEx {\r\n    struct Transformation {\r\n        // The deployment nonce for the transformer.\r\n        // The address of the transformer contract will be derived from this\r\n        // value.\r\n        uint32 deploymentNonce;\r\n        // Arbitrary data to pass to the transformer.\r\n        bytes data;\r\n    }\r\n\r\n    /// @dev Executes a series of transformations to convert an ERC20 `inputToken`\r\n    ///      to an ERC20 `outputToken`.\r\n    /// @param inputToken The token being provided by the sender.\r\n    ///        If `0xeee...`, ETH is implied and should be provided with the call.`\r\n    /// @param outputToken The token to be acquired by the sender.\r\n    ///        `0xeee...` implies ETH.\r\n    /// @param inputTokenAmount The amount of `inputToken` to take from the sender.\r\n    /// @param minOutputTokenAmount The minimum amount of `outputToken` the sender\r\n    ///        must receive for the entire transformation to succeed.\r\n    /// @param transformations The transformations to execute on the token balance(s)\r\n    ///        in sequence.\r\n    /// @return outputTokenAmount The amount of `outputToken` received by the sender.\r\n    function transformERC20(\r\n        IERC20 inputToken,\r\n        IERC20 outputToken,\r\n        uint256 inputTokenAmount,\r\n        uint256 minOutputTokenAmount,\r\n        Transformation[] calldata transformations\r\n    ) external payable returns (uint256 outputTokenAmount);\r\n}"
    },
    "contracts/lib/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromInt(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(x << 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64-bit integer number\r\n     */\r\n    function toInt(int128 x) internal pure returns (int64) {\r\n        unchecked {\r\n            return int64(x >> 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromUInt(uint256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(int256(x << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return unsigned 64-bit integer number\r\n     */\r\n    function toUInt(int128 x) internal pure returns (uint64) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return uint64(uint128(x >> 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function from128x128(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = x >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 128.128 fixed point number\r\n     */\r\n    function to128x128(int128 x) internal pure returns (int256) {\r\n        unchecked {\r\n            return int256(x) << 64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function add(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) + y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sub(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) - y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function mul(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = (int256(x) * y) >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 256-bit integer number\r\n     */\r\n    function muli(int128 x, int256 y) internal pure returns (int256) {\r\n        unchecked {\r\n            if (x == MIN_64x64) {\r\n                require(\r\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n                        y <= 0x1000000000000000000000000000000000000000000000000\r\n                );\r\n                return -y << 63;\r\n            } else {\r\n                bool negativeResult = false;\r\n                if (x < 0) {\r\n                    x = -x;\r\n                    negativeResult = true;\r\n                }\r\n                if (y < 0) {\r\n                    y = -y; // We rely on overflow behavior here\r\n                    negativeResult = !negativeResult;\r\n                }\r\n                uint256 absoluteResult = mulu(x, uint256(y));\r\n                if (negativeResult) {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    );\r\n                    return -int256(absoluteResult); // We rely on overflow behavior here\r\n                } else {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                    );\r\n                    return int256(absoluteResult);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 256-bit integer number\r\n     */\r\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\r\n        unchecked {\r\n            if (y == 0) return 0;\r\n\r\n            require(x >= 0);\r\n\r\n            uint256 lo = (uint256(int256(x)) *\r\n                (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n            uint256 hi = uint256(int256(x)) * (y >> 128);\r\n\r\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            hi <<= 64;\r\n\r\n            require(\r\n                hi <=\r\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -\r\n                        lo\r\n            );\r\n            return hi + lo;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function div(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            int256 result = (int256(x) << 64) / y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divi(int256 x, int256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x; // We rely on overflow behavior here\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\r\n            if (negativeResult) {\r\n                require(absoluteResult <= 0x80000000000000000000000000000000);\r\n                return -int128(absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int128(absoluteResult); // We rely on overflow behavior here\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            uint128 result = divuu(x, y);\r\n            require(result <= uint128(MAX_64x64));\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function neg(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return -x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function abs(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function inv(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != 0);\r\n            int256 result = int256(0x100000000000000000000000000000000) / x;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function avg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            return int128((int256(x) + int256(y)) >> 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 m = int256(x) * int256(y);\r\n            require(m >= 0);\r\n            require(\r\n                m <\r\n                    0x4000000000000000000000000000000000000000000000000000000000000000\r\n            );\r\n            return int128(sqrtu(uint256(m)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y uint256 value\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            bool negative = x < 0 && y & 1 == 1;\r\n\r\n            uint256 absX = uint128(x < 0 ? -x : x);\r\n            uint256 absResult;\r\n            absResult = 0x100000000000000000000000000000000;\r\n\r\n            if (absX <= 0x10000000000000000) {\r\n                absX <<= 63;\r\n                while (y != 0) {\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x2 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x4 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x8 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    y >>= 4;\r\n                }\r\n\r\n                absResult >>= 64;\r\n            } else {\r\n                uint256 absXShift = 63;\r\n                if (absX < 0x1000000000000000000000000) {\r\n                    absX <<= 32;\r\n                    absXShift -= 32;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000) {\r\n                    absX <<= 16;\r\n                    absXShift -= 16;\r\n                }\r\n                if (absX < 0x1000000000000000000000000000000) {\r\n                    absX <<= 8;\r\n                    absXShift -= 8;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000000) {\r\n                    absX <<= 4;\r\n                    absXShift -= 4;\r\n                }\r\n                if (absX < 0x40000000000000000000000000000000) {\r\n                    absX <<= 2;\r\n                    absXShift -= 2;\r\n                }\r\n                if (absX < 0x80000000000000000000000000000000) {\r\n                    absX <<= 1;\r\n                    absXShift -= 1;\r\n                }\r\n\r\n                uint256 resultShift = 0;\r\n                while (y != 0) {\r\n                    require(absXShift < 64);\r\n\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                        resultShift += absXShift;\r\n                        if (absResult > 0x100000000000000000000000000000000) {\r\n                            absResult >>= 1;\r\n                            resultShift += 1;\r\n                        }\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n                    absXShift <<= 1;\r\n                    if (absX >= 0x100000000000000000000000000000000) {\r\n                        absX >>= 1;\r\n                        absXShift += 1;\r\n                    }\r\n\r\n                    y >>= 1;\r\n                }\r\n\r\n                require(resultShift < 64);\r\n                absResult >>= 64 - resultShift;\r\n            }\r\n            int256 result = negative ? -int256(absResult) : int256(absResult);\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sqrt(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return int128(sqrtu(uint256(int256(x)) << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function log_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            int256 msb = 0;\r\n            int256 xc = x;\r\n            if (xc >= 0x10000000000000000) {\r\n                xc >>= 64;\r\n                msb += 64;\r\n            }\r\n            if (xc >= 0x100000000) {\r\n                xc >>= 32;\r\n                msb += 32;\r\n            }\r\n            if (xc >= 0x10000) {\r\n                xc >>= 16;\r\n                msb += 16;\r\n            }\r\n            if (xc >= 0x100) {\r\n                xc >>= 8;\r\n                msb += 8;\r\n            }\r\n            if (xc >= 0x10) {\r\n                xc >>= 4;\r\n                msb += 4;\r\n            }\r\n            if (xc >= 0x4) {\r\n                xc >>= 2;\r\n                msb += 2;\r\n            }\r\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n            int256 result = (msb - 64) << 64;\r\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n                ux *= ux;\r\n                uint256 b = ux >> 255;\r\n                ux >>= 127 + b;\r\n                result += bit * int256(b);\r\n            }\r\n\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function ln(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            return\r\n                int128(\r\n                    int256(\r\n                        (uint256(int256(log_2(x))) *\r\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            uint256 result = 0x80000000000000000000000000000000;\r\n\r\n            if (x & 0x8000000000000000 > 0)\r\n                result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\r\n            if (x & 0x4000000000000000 > 0)\r\n                result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\r\n            if (x & 0x2000000000000000 > 0)\r\n                result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\r\n            if (x & 0x1000000000000000 > 0)\r\n                result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\r\n            if (x & 0x800000000000000 > 0)\r\n                result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\r\n            if (x & 0x400000000000000 > 0)\r\n                result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\r\n            if (x & 0x200000000000000 > 0)\r\n                result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\r\n            if (x & 0x100000000000000 > 0)\r\n                result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\r\n            if (x & 0x80000000000000 > 0)\r\n                result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\r\n            if (x & 0x40000000000000 > 0)\r\n                result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\r\n            if (x & 0x20000000000000 > 0)\r\n                result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\r\n            if (x & 0x10000000000000 > 0)\r\n                result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\r\n            if (x & 0x8000000000000 > 0)\r\n                result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\r\n            if (x & 0x4000000000000 > 0)\r\n                result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\r\n            if (x & 0x2000000000000 > 0)\r\n                result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\r\n            if (x & 0x1000000000000 > 0)\r\n                result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\r\n            if (x & 0x800000000000 > 0)\r\n                result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\r\n            if (x & 0x400000000000 > 0)\r\n                result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\r\n            if (x & 0x200000000000 > 0)\r\n                result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\r\n            if (x & 0x100000000000 > 0)\r\n                result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\r\n            if (x & 0x80000000000 > 0)\r\n                result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\r\n            if (x & 0x40000000000 > 0)\r\n                result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\r\n            if (x & 0x20000000000 > 0)\r\n                result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\r\n            if (x & 0x10000000000 > 0)\r\n                result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\r\n            if (x & 0x8000000000 > 0)\r\n                result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\r\n            if (x & 0x4000000000 > 0)\r\n                result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\r\n            if (x & 0x2000000000 > 0)\r\n                result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\r\n            if (x & 0x1000000000 > 0)\r\n                result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\r\n            if (x & 0x800000000 > 0)\r\n                result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\r\n            if (x & 0x400000000 > 0)\r\n                result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\r\n            if (x & 0x200000000 > 0)\r\n                result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\r\n            if (x & 0x100000000 > 0)\r\n                result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\r\n            if (x & 0x80000000 > 0)\r\n                result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\r\n            if (x & 0x40000000 > 0)\r\n                result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\r\n            if (x & 0x20000000 > 0)\r\n                result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\r\n            if (x & 0x10000000 > 0)\r\n                result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\r\n            if (x & 0x8000000 > 0)\r\n                result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\r\n            if (x & 0x4000000 > 0)\r\n                result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\r\n            if (x & 0x2000000 > 0)\r\n                result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\r\n            if (x & 0x1000000 > 0)\r\n                result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\r\n            if (x & 0x800000 > 0)\r\n                result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\r\n            if (x & 0x400000 > 0)\r\n                result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\r\n            if (x & 0x200000 > 0)\r\n                result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\r\n            if (x & 0x100000 > 0)\r\n                result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\r\n            if (x & 0x80000 > 0)\r\n                result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\r\n            if (x & 0x40000 > 0)\r\n                result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\r\n            if (x & 0x20000 > 0)\r\n                result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\r\n            if (x & 0x10000 > 0)\r\n                result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\r\n            if (x & 0x8000 > 0)\r\n                result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\r\n            if (x & 0x4000 > 0)\r\n                result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\r\n            if (x & 0x2000 > 0)\r\n                result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\r\n            if (x & 0x1000 > 0)\r\n                result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\r\n            if (x & 0x800 > 0)\r\n                result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\r\n            if (x & 0x400 > 0)\r\n                result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\r\n            if (x & 0x200 > 0)\r\n                result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\r\n            if (x & 0x100 > 0)\r\n                result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\r\n            if (x & 0x80 > 0)\r\n                result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\r\n            if (x & 0x40 > 0)\r\n                result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\r\n            if (x & 0x20 > 0)\r\n                result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\r\n            if (x & 0x10 > 0)\r\n                result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\r\n            if (x & 0x8 > 0)\r\n                result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\r\n            if (x & 0x4 > 0)\r\n                result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\r\n            if (x & 0x2 > 0)\r\n                result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\r\n            if (x & 0x1 > 0)\r\n                result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\r\n\r\n            result >>= uint256(int256(63 - (x >> 64)));\r\n            require(result <= uint256(int256(MAX_64x64)));\r\n\r\n            return int128(int256(result));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            return\r\n                exp_2(\r\n                    int128(\r\n                        (int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 64.64-bit fixed point number\r\n     */\r\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            uint256 result;\r\n\r\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                result = (x << 64) / y;\r\n            else {\r\n                uint256 msb = 192;\r\n                uint256 xc = x >> 192;\r\n                if (xc >= 0x100000000) {\r\n                    xc >>= 32;\r\n                    msb += 32;\r\n                }\r\n                if (xc >= 0x10000) {\r\n                    xc >>= 16;\r\n                    msb += 16;\r\n                }\r\n                if (xc >= 0x100) {\r\n                    xc >>= 8;\r\n                    msb += 8;\r\n                }\r\n                if (xc >= 0x10) {\r\n                    xc >>= 4;\r\n                    msb += 4;\r\n                }\r\n                if (xc >= 0x4) {\r\n                    xc >>= 2;\r\n                    msb += 2;\r\n                }\r\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\r\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 hi = result * (y >> 128);\r\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 xh = x >> 192;\r\n                uint256 xl = x << 64;\r\n\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n                lo = hi << 128;\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n\r\n                assert(xh == hi >> 128);\r\n\r\n                result += xl / y;\r\n            }\r\n\r\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return unsigned 128-bit integer number\r\n     */\r\n    function sqrtu(uint256 x) private pure returns (uint128) {\r\n        unchecked {\r\n            if (x == 0) return 0;\r\n            else {\r\n                uint256 xx = x;\r\n                uint256 r = 1;\r\n                if (xx >= 0x100000000000000000000000000000000) {\r\n                    xx >>= 128;\r\n                    r <<= 64;\r\n                }\r\n                if (xx >= 0x10000000000000000) {\r\n                    xx >>= 64;\r\n                    r <<= 32;\r\n                }\r\n                if (xx >= 0x100000000) {\r\n                    xx >>= 32;\r\n                    r <<= 16;\r\n                }\r\n                if (xx >= 0x10000) {\r\n                    xx >>= 16;\r\n                    r <<= 8;\r\n                }\r\n                if (xx >= 0x100) {\r\n                    xx >>= 8;\r\n                    r <<= 4;\r\n                }\r\n                if (xx >= 0x10) {\r\n                    xx >>= 4;\r\n                    r <<= 2;\r\n                }\r\n                if (xx >= 0x4) {\r\n                    r <<= 1;\r\n                }\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1; // Seven iterations should be enough\r\n                uint256 r1 = x / r;\r\n                return uint128(r < r1 ? r : r1);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lib/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y)\n        internal\n        pure\n        returns (uq144x112 memory)\n    {\n        uint256 z;\n        require(\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\n            \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n        );\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}"
    },
    "contracts/lib/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide z by the denominator.\r\n            z := div(z, denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // First, divide z - 1 by the denominator and add 1.\r\n            // We allow z - 1 to underflow if z is 0, because we multiply the\r\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\r\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z) // Like multiplying by 2 ** 64.\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z) // Like multiplying by 2 ** 32.\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z) // Like multiplying by 2 ** 16.\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z) // Like multiplying by 2 ** 8.\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z) // Like multiplying by 2 ** 4.\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z) // Like multiplying by 2 ** 2.\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}"
    },
    "contracts/lib/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/liquidation/flashloan/AAVEFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport {IFlashLoanSimpleReceiver} from '@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanSimpleReceiver.sol';\r\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\r\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\r\n\r\nimport \"./FlashLoanHandler.sol\";\r\n\r\nabstract contract AaaveFlashLoan is FlashLoanHandler, IFlashLoanSimpleReceiver {\r\n    using SafeERC20 for ERC20;\r\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\r\n    IPool public immutable override POOL;\r\n\r\n    constructor(address provider) FlashLoanHandler() {\r\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(provider);\r\n        POOL = IPool(ADDRESSES_PROVIDER.getPool());\r\n    }\r\n\r\n    function _initiateFlashLoan(address asset, uint256 amount, bytes memory data) internal virtual override {\r\n        POOL.flashLoanSimple(address(this), asset, amount, data, 0);\r\n    }\r\n\r\n    function executeOperation(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        address iniator, // initiator\r\n        bytes memory params\r\n    ) public override returns (bool) {\r\n        require(msg.sender == address(POOL));\r\n        require(iniator == address(this));\r\n        uint256 amountToRepay = amount + premium;\r\n        _handleCallBack(asset, amountToRepay, params);\r\n    }\r\n\r\n    function _repayFlashLoan(address asset, uint amount) internal virtual override returns(uint256) {\r\n        ERC20 erc20 = ERC20(asset);\r\n        erc20.safeApprove(address(POOL), amount);\r\n        return erc20.balanceOf(address(this)) - amount;\r\n    }\r\n\r\n}"
    },
    "contracts/liquidation/flashloan/FlashLoanHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nabstract contract FlashLoanHandler {\r\n\r\n    constructor() {}\r\n\r\n    function _initiateFlashLoan(address asset, uint256 amount, bytes memory data) internal virtual;\r\n\r\n    function _handleCallBack(address asset, uint256 repayAmount, bytes memory params) public virtual;\r\n\r\n    function _repayFlashLoan(address asset, uint amount) internal virtual returns(uint256);\r\n}"
    },
    "contracts/liquidation/flashloan/SolidlyFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\nimport {ISolidlyPairFactory} from \"../../interfaces/ISolidlyPairFactory.sol\";\r\nimport {ISolidlyPair} from \"../../interfaces/ISolidlyPair.sol\";\r\n\r\nimport \"./FlashLoanHandler.sol\";\r\n\r\nabstract contract SolidlyFlashLoan is FlashLoanHandler {\r\n    using SafeERC20 for ERC20;\r\n\r\n    ISolidlyPair public immutable pair;\r\n    ISolidlyPairFactory public immutable pairFactory;\r\n\r\n    struct HookParams {\r\n        address asset;\r\n        uint amount;\r\n        bytes data;\r\n    }\r\n\r\n    constructor(address _pairFactory, address _pair) FlashLoanHandler() {\r\n        pairFactory = ISolidlyPairFactory(_pairFactory);\r\n        pair = ISolidlyPair(_pair);\r\n    }\r\n\r\n    function _initiateFlashLoan(address asset, uint256 amount, bytes memory data) internal virtual override {\r\n        (address token0,) = pair.tokens();\r\n        (uint256 amount0, uint256 amount1) = asset == token0? (amount, uint256(0)): (uint256(0), amount);\r\n        pair.swap(amount0, amount1, address(this), abi.encode(HookParams(asset, amount, data)));\r\n    }\r\n\r\n    function hook(\r\n        address iniator,\r\n        uint256,\r\n        uint256,\r\n        bytes memory data\r\n    ) public {\r\n        require(msg.sender == address(pair));\r\n        require(iniator == address(this));\r\n        HookParams memory params = abi.decode(data, (HookParams));\r\n        // Add fees to the amount borrowed\r\n        uint toRepay = params.amount * (pairFactory.getFee(pair.stable())+10001) / 10000;\r\n        _handleCallBack(params.asset, toRepay, params.data);\r\n    }\r\n\r\n    function _repayFlashLoan(address asset, uint256 amount) internal virtual override returns(uint256){\r\n        (address token0, address token1) = pair.tokens();\r\n        bool shouldRepay0 = token0 != asset;\r\n        ERC20 repay = ERC20(shouldRepay0? token0: token1);\r\n        uint256 repayBalance = repay.balanceOf(address(this));\r\n        repay.safeTransfer(address(pair), repayBalance);\r\n        return ERC20(asset).balanceOf(address(this));\r\n    }\r\n}\r\n\r\ncontract SolidlyFlashLoanTest is SolidlyFlashLoan {\r\n    constructor(address _pairFactory, address _pair) SolidlyFlashLoan(_pairFactory, _pair){}\r\n\r\n    function flash(address asset, uint256 amount, bytes memory data) external {\r\n        _initiateFlashLoan(asset, amount, data);\r\n    }\r\n\r\n    function _handleCallBack(address asset, uint amount, bytes memory) public virtual override {\r\n        _repayFlashLoan(asset, amount);\r\n    }\r\n}"
    },
    "contracts/liquidation/SimpleLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"../interfaces/IMarket.sol\";\r\n\r\nimport \"./flashloan/FlashLoanHandler.sol\";\r\nimport \"./swaps/Swap.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nabstract contract SimpleLiquidator is FlashLoanHandler, Swap {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct LiquidationParams {\r\n        address market;\r\n        uint256[] accounts;\r\n        uint256[] amounts;\r\n        bytes swapData;\r\n    }\r\n\r\n    address treasury;\r\n\r\n    constructor(address _treasury){\r\n        treasury = _treasury;\r\n    }\r\n\r\n    function liquidate(\r\n        address flashLoanAsset,\r\n        uint flashLoanAmount,\r\n        bytes memory liquidationParams\r\n    ) external {\r\n        _initiateFlashLoan(flashLoanAsset, flashLoanAmount, liquidationParams);\r\n    }\r\n\r\n    function _handleCallBack(address principal, uint256 loanAmount, bytes memory params) public override {\r\n\r\n        LiquidationParams memory liqu = abi.decode(params, (LiquidationParams));\r\n        IMarket market = IMarket(liqu.market);\r\n        IERC20 liquPrincipal = market.debtToken();\r\n        IERC20 liquCollateral = market.collateralToken();\r\n        liquPrincipal.safeIncreaseAllowance(liqu.market, type(uint256).max);\r\n        require(address(liquPrincipal) == principal, \"Wrong loan?\");\r\n        for(uint256 i = 0; i < liqu.accounts.length; i++){\r\n            market.liquidate(liqu.accounts[i], liqu.amounts[i]);\r\n        }\r\n        uint256 collateralOut = market.claimLiquidationRewards();\r\n        _swap(liquCollateral, liquPrincipal, collateralOut, loanAmount, liqu.swapData);\r\n\r\n        uint256 profit = _repayFlashLoan(principal, loanAmount);\r\n        liquPrincipal.safeTransfer(treasury, profit);\r\n    }\r\n}"
    },
    "contracts/liquidation/SimpleSolidlyLiqu.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./flashloan/SolidlyFlashLoan.sol\";\r\nimport \"./swaps/SolidlySwap.sol\";\r\nimport \"./SimpleLiquidator.sol\";\r\n\r\ncontract SimpleSolidlyLiqu is SimpleLiquidator, SolidlyFlashLoan, SolidlySwap {\r\n    constructor(address treasury, address pairFactory, address pair) \r\n        SimpleLiquidator(treasury) \r\n        SolidlyFlashLoan(pairFactory, pair) {\r\n\r\n    }\r\n\r\n}"
    },
    "contracts/liquidation/swaps/SolidlySwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport {Swap} from \"./Swap.sol\";\r\n\r\nimport {ISolidlyRouter} from \"../../interfaces/ISolidlyRouter.sol\";\r\n\r\ncontract SolidlySwap is Swap {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function _swap(\r\n        IERC20 input, \r\n        IERC20, \r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        bytes memory data\r\n    ) internal override returns(uint256){\r\n        (address routerAddress, ISolidlyRouter.route[] memory swapData) = abi.decode(data, (address, ISolidlyRouter.route[]));\r\n        if (swapData.length == 0) {\r\n            return amountIn;\r\n        }\r\n        \r\n        input.safeIncreaseAllowance(routerAddress, amountIn);\r\n        require(input.allowance(address(this), routerAddress) >= amountIn, \"not enough allowance\");\r\n        ISolidlyRouter router = ISolidlyRouter(routerAddress);\r\n        uint256[] memory amounts = router.swapExactTokensForTokens(amountIn, amountOutMin, swapData, address(this), block.timestamp);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n}\r\n\r\ncontract SolidlySwapExt is SolidlySwap {\r\n    function swap(\r\n        address input,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        bytes memory data\r\n    ) external {\r\n        _swap(IERC20(input), IERC20(address(0)), amountIn, amountOutMin, data);\r\n    }\r\n}"
    },
    "contracts/liquidation/swaps/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nabstract contract Swap {\r\n    function _swap(IERC20 input, IERC20 output, uint256 amountIn, uint256 amountOutMin, bytes memory data) internal virtual returns(uint256);\r\n}"
    },
    "contracts/liquidation/swaps/ZeroExSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport {Swap} from \"./Swap.sol\";\r\n\r\nimport {IZeroEx} from \"../../interfaces/IZeroEx.sol\";\r\n\r\ncontract ZeroExSwap is Swap {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function _swap(\r\n        IERC20 input, \r\n        IERC20 output, \r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        bytes memory data\r\n    ) internal override returns(uint256){\r\n        (address routerAddress, bytes memory swapData) = abi.decode(data, (address, bytes));\r\n        input.safeApprove(routerAddress, amountIn);\r\n        IZeroEx router = IZeroEx(routerAddress);\r\n        IZeroEx.Transformation[] memory transformations = abi.decode(swapData, (IZeroEx.Transformation[]));\r\n        return router.transformERC20(\r\n            input, \r\n            output, \r\n            amountIn, \r\n            amountOutMin, \r\n            transformations\r\n        );\r\n    }\r\n}"
    },
    "contracts/markets/BaseMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"../interfaces/IPriceProvider.sol\";\r\nimport \"./interests/InterestMarket.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/// @title Create a base vault for collaterals\r\ncontract BaseMarket is ReentrancyGuard, InterestMarket {\r\n    using SafeERC20 for ERC20;\r\n\r\n    uint public constant HEALTH_RATIO_DECIMALS = 18;\r\n    uint public constant LIQUIDATION_PENALTY_DECIMALS = 3;\r\n    uint public constant LIQUIDATION_THRESHOLD_DECIMALS = 18;\r\n    uint public constant CLOSING_FEE_DECIMALS = 4;\r\n\r\n    IPriceProvider public priceProvider;\r\n\r\n    /** Configurations */\r\n\r\n    uint256 public liquidationThreshold;\r\n    uint256 public liquidationMaxHR;\r\n    /**\r\n     * @notice Liquidator cannot leave less than this amount when liquidationg the account\r\n     */\r\n    uint256 public smallAccountThreshold;\r\n\r\n    uint256 public closingFee;\r\n\r\n    uint256 public treasuryAccountId;\r\n\r\n    uint256 public liquidationPenalty;\r\n\r\n    ERC20 public collateralToken;\r\n    ERC20 public debtToken;\r\n\r\n    event CollateralDeposited(uint256 accountID, uint256 amount);\r\n    event CollateralWithdrawn(uint256 accountID, uint256 amount);\r\n    event TokenBorrowed(uint256 accountID, uint256 amount);\r\n    event TokenRepaid(uint256 accountID, uint256 amount, uint256 closingFee);\r\n    event AccountLiquidated(\r\n        uint256 accountID,\r\n        address owner,\r\n        address buyer,\r\n        uint256 debtRepaid,\r\n        uint256 collateralLiquidated,\r\n        uint256 closingFee\r\n    );\r\n\r\n    mapping(address => uint256) public liquidatorRewards;\r\n\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 _liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address _debtToken,\r\n        address _collateralToken,\r\n        string memory baseURI,\r\n        uint _liquidationMaxHR,\r\n        uint _liquidationPenalty,\r\n        uint _closingFee\r\n    ) InterestMarket(name, symbol, baseURI) {\r\n        require(priceProviderAddress != address(0));\r\n        require(_liquidationThreshold > 10 ** LIQUIDATION_THRESHOLD_DECIMALS);\r\n        //  | decimals start here\r\n        closingFee = _closingFee; // 0.5%\r\n        priceProvider = IPriceProvider(priceProviderAddress);\r\n\r\n        collateralToken = ERC20(_collateralToken);\r\n        debtToken = ERC20(_debtToken);\r\n\r\n        liquidationPenalty = _liquidationPenalty; // /10 so 1.1\r\n        liquidationThreshold = _liquidationThreshold;\r\n        liquidationMaxHR = _liquidationMaxHR;\r\n        smallAccountThreshold = 10 * 10 ** debtToken.decimals();\r\n    }\r\n\r\n    modifier onlyAccountOwner(uint256 accountID) {\r\n        require(_exists(accountID), \"Account does not exist\");\r\n        require(\r\n            ownerOf(accountID) == msg.sender,\r\n            \"Vault is not owned by caller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    ////////\r\n    /// @notice Returns the maximum available debt\r\n    /// @return maxDebt\r\n    function getAvailableDebt() public view returns (uint256) {\r\n        return debtToken.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Checks if a vault with the given ID exists\r\n    /// @return exists true if it exists false otherwise\r\n    function exists(uint256 accountID) external view returns (bool) {\r\n        return _exists(accountID);\r\n    }\r\n\r\n    /// @notice it will return principal Price\r\n    function getDebtPrice() public view returns (uint256) {\r\n        return 10 ** priceProvider.DECIMALS();\r\n    }\r\n\r\n    /// @notice returns collateral price\r\n    /// @return ethPrice\r\n    function getCollateralPrice() public view returns (uint256) {\r\n        return priceProvider.getSafePrice(address(collateralToken));\r\n    }\r\n\r\n    function principalAmount(\r\n        uint256 accountID\r\n    ) external view virtual returns (uint256) {\r\n        return _principalAmount(accountID);\r\n    }\r\n\r\n    function collateralAmount(\r\n        uint256 accountID\r\n    ) external view virtual returns (uint256) {\r\n        return _collateralAmount(accountID);\r\n    }\r\n\r\n    /** functions to satisfy the InterestModel abstract contract. The BaseMarket has no interest */\r\n    function _setInterestRate(\r\n        uint256 _yearlyInterestRate\r\n    ) internal virtual override {}\r\n\r\n    function _compoundInterest() internal virtual override {}\r\n\r\n    function _interestGrace(\r\n        uint256 principal\r\n    ) internal view virtual override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function compoundInterest() external {\r\n        _compoundInterest();\r\n    }\r\n\r\n    /// @notice returns the collateral value \r\n    /// @param _collateralAmount The amount of collateral to get valued\r\n    /// @dev Returns the same amount of decimals as the oracle\r\n    /// @return collateralValue Collateral value \r\n    function calculateCollateralValue(\r\n        uint256 _collateralAmount\r\n    ) public view returns (uint256) {\r\n        uint256 collateralPrice = getCollateralPrice();\r\n        require(collateralPrice != 0, \"oracle is not ready\");\r\n        uint256 collateralValue = (_collateralAmount * collateralPrice) /\r\n            (10 ** collateralToken.decimals());\r\n\r\n        return collateralValue;\r\n    }\r\n\r\n    /// @notice returns the principal value\r\n    /// @param _principalAmount The amount of principal to get valued\r\n    /// @dev Returns the same amount of decimals as the oracle\r\n    /// @return principalValue principal value\r\n    function calculatePrincipalValue(\r\n        uint256 _principalAmount\r\n    ) public view returns (uint256) {\r\n        uint256 debtPrice = getDebtPrice();\r\n        require(debtPrice != 0, \"oracle is not ready\");\r\n        uint256 debtValue = (_principalAmount * debtPrice) /\r\n            (10 ** debtToken.decimals());\r\n        return debtValue;\r\n    }\r\n\r\n    /// @notice Creates a new vault and returns its id\r\n    /// @return id is the new vault's id\r\n    function openAccount() external returns (uint256) {\r\n        return _openAccount();\r\n    }\r\n\r\n    /// @notice deposits the given amount of collateral to the vault\r\n    /// @param accountID is the vault's id\r\n    /// @param amount is the amount to deposit\r\n    function deposit(uint256 accountID, uint256 amount) external {\r\n        require(_exists(accountID), \"Account does not exist\");\r\n        collateralToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        _increaseCollateralAmount(accountID, amount);\r\n\r\n        emit CollateralDeposited(accountID, amount);\r\n    }\r\n\r\n    /// @notice Withdrawls collateral from the vault and updates vault with the new amount\r\n    /// @param accountID is the vault's id\r\n    /// @param amount is the amount to withdraw\r\n    /// @dev Modifier: onlyAccountOwner: requires the owner to be the caller of the function, nonReentrant\r\n    function withdraw(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) external onlyAccountOwner(accountID) nonReentrant {\r\n        _decreaseCollateralAmount(accountID, amount);\r\n        if (_principalAmount(accountID) != 0) {\r\n            require(\r\n                !isLiquidatable(accountID),\r\n                \"Withdrawal would put health ratio below 1\"\r\n            );\r\n        }\r\n        collateralToken.safeTransfer(msg.sender, amount);\r\n\r\n        emit CollateralWithdrawn(accountID, amount);\r\n    }\r\n\r\n    function updateSmallAccountThreshold(\r\n        uint256 _newThreshold\r\n    ) external virtual {\r\n        smallAccountThreshold = _newThreshold;\r\n    }\r\n\r\n    /// @notice borrows token from the vault and increases debt\r\n    /// @dev checks to make sure there is no bad debt\r\n    /// @param accountID is the vault's ID\r\n    /// @param amount is the amount to borrow\r\n    function borrow(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) public virtual onlyAccountOwner(accountID) {\r\n        require(amount > 0, \"Must borrow non-zero amount\");\r\n        require(\r\n            amount <= getAvailableDebt(),\r\n            \"borrow: Cannot be over available supply.\"\r\n        );\r\n\r\n        _compoundInterest();\r\n        uint256 principal = _increasePrincipalAmount(accountID, amount);\r\n        require(!isLiquidatable(accountID), \"borrow: Health ratio below 100\");\r\n        require(\r\n            principal >= smallAccountThreshold,\r\n            \"Outstanding principal amount is too small.\"\r\n        );\r\n\r\n        debtToken.safeTransfer(msg.sender, amount);\r\n\r\n        emit TokenBorrowed(accountID, amount);\r\n    }\r\n\r\n    /// @notice pays back the token borrowed previously\r\n    /// @dev the amount should not be too low, or more than the debt itself\r\n    /// @param accountID is the vault's ID\r\n    /// @param amount is the amount to pay back\r\n    function repay(uint256 accountID, uint256 amount) virtual public {\r\n        require(\r\n            debtToken.balanceOf(msg.sender) >= amount,\r\n            \"Token balance too low\"\r\n        );\r\n        _compoundInterest();\r\n        uint256 principal = _decreasePrincipalAmount(accountID, amount);\r\n        debtToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        uint256 totalClosingFee = _applyClosingFee(accountID, amount);\r\n        require(\r\n            principal >= smallAccountThreshold || principal == 0,\r\n            \"Outstanding principal amount is too small.\"\r\n        );\r\n        emit TokenRepaid(accountID, amount, totalClosingFee);\r\n    }\r\n\r\n    function _applyClosingFee(\r\n        uint256 accountID,\r\n        uint amount\r\n    ) internal returns (uint256) {\r\n        uint256 totalClosingFee = _calculateClosingFee(amount);\r\n        _decreaseCollateralAmount(accountID, totalClosingFee);\r\n        _increaseCollateralAmount(treasuryAccountId, totalClosingFee);\r\n        return totalClosingFee;\r\n    }\r\n\r\n    function _calculateClosingFee(\r\n        uint256 principalRepaid\r\n    ) internal view returns (uint256) {\r\n        uint256 collateralPrice = getCollateralPrice();\r\n        uint256 principalPrice = getDebtPrice();\r\n        return\r\n            (principalRepaid * (10**collateralToken.decimals()) * closingFee * principalPrice) /\r\n            (10 ** (CLOSING_FEE_DECIMALS+debtToken.decimals()) * collateralPrice);\r\n    }\r\n\r\n    /// @notice Returns if the vault isLiquidatable\r\n    /// @param accountID is the vault's ID\r\n    /// @return isLiquidatable which is a boolean\r\n    function isLiquidatable(uint256 accountID) public view returns (bool) {\r\n        require(_exists(accountID), \"Account does not exist\");\r\n        return calculateHealthRatio(accountID) < 10 ** HEALTH_RATIO_DECIMALS;\r\n    }\r\n\r\n    function isSmallAccount(uint256 accountID) external view returns (bool) {\r\n        return _principalAmount(accountID) <= smallAccountThreshold;\r\n    }\r\n\r\n    function isMediumAccount(uint256 accountID) external view returns (bool) {\r\n        return _principalAmount(accountID) <= 2 * smallAccountThreshold;\r\n    }\r\n\r\n    /// @notice Liquidates accountID\r\n    /// @param accountID is the vault's ID\r\n    /// @param amountLiquidated amount of debt token liquidated\r\n    function liquidate(uint256 accountID, uint amountLiquidated) external returns (uint256){\r\n        _compoundInterest();\r\n        require(\r\n            isLiquidatable(accountID),\r\n            \"Vault is not below minimum collateral percentage\"\r\n        );\r\n        uint256 pa = _principalAmount(accountID);\r\n        require(\r\n            amountLiquidated <= pa,\r\n            \"liquidatateVault: amount liquidated is gt than debt balance\"\r\n        );\r\n\r\n        require(\r\n            debtToken.balanceOf(msg.sender) >= amountLiquidated,\r\n            \"Token balance too low to pay off outstanding debt\"\r\n        );\r\n\r\n        debtToken.safeTransferFrom(msg.sender, address(this), amountLiquidated);\r\n\r\n        uint256 liquidatorReward = calculateLiquidatorReward(amountLiquidated);\r\n        bool smallAccount = pa <= smallAccountThreshold;\r\n        bool mediumAccount = pa <= 2 * smallAccountThreshold;\r\n\r\n        uint principalAmountLeft = _decreasePrincipalAmount(\r\n            accountID,\r\n            amountLiquidated\r\n        );\r\n        uint256 totalClosingFee = _applyClosingFee(accountID, amountLiquidated);\r\n\r\n        // deduct the amount from the vault's collateral\r\n        _decreaseCollateralAmount(accountID, liquidatorReward);\r\n        bool accountEmpty = principalAmountLeft == 0;\r\n        if (smallAccount) {\r\n            require(\r\n                accountEmpty,\r\n                \"Small accounts have to be liquidated entirely\"\r\n            );\r\n        } else {\r\n            if (!mediumAccount) {\r\n                bool hrLteMax = calculateHealthRatio(accountID) <=\r\n                    liquidationMaxHR;\r\n                require(hrLteMax, \"too much collateral is liquidated\");\r\n            }\r\n            require(\r\n                accountEmpty || principalAmountLeft > smallAccountThreshold,\r\n                \"Cannot leave a small amount of debt\"\r\n            );\r\n        }\r\n\r\n        // assign the reward the liquidator's account\r\n        liquidatorRewards[msg.sender] =\r\n            liquidatorRewards[msg.sender] +\r\n            liquidatorReward;\r\n\r\n        emit AccountLiquidated(\r\n            accountID,\r\n            ownerOf(accountID),\r\n            msg.sender,\r\n            amountLiquidated,\r\n            liquidatorReward,\r\n            totalClosingFee\r\n        );\r\n        return liquidatorReward;\r\n    }\r\n\r\n    /// @notice Calculates the liquidators' reward\r\n    function calculateLiquidatorReward(\r\n        uint256 amountLiquidated\r\n    ) public view returns (uint256) {\r\n        return\r\n            (amountLiquidated * (10**collateralToken.decimals()) * liquidationPenalty * getDebtPrice()) /\r\n            (10 ** (LIQUIDATION_PENALTY_DECIMALS+debtToken.decimals()) * getCollateralPrice());\r\n    }\r\n\r\n    function calculateHealthRatio(\r\n        uint256 _accountID\r\n    ) public view returns (uint256) {\r\n        uint256 principalValue = calculatePrincipalValue(_principalAmount(_accountID));\r\n        if (principalValue == 0) {\r\n            return type(uint256).max;\r\n        }\r\n        return ((calculateCollateralValue(_collateralAmount(_accountID)) *\r\n            (10 ** (LIQUIDATION_THRESHOLD_DECIMALS + HEALTH_RATIO_DECIMALS))) /\r\n            (liquidationThreshold * principalValue));\r\n    }\r\n\r\n    function claimLiquidationRewards() public nonReentrant returns (uint256) {\r\n        require(\r\n            liquidatorRewards[msg.sender] > 0,\r\n            \"Don't have anything for you.\"\r\n        );\r\n        uint256 amount = liquidatorRewards[msg.sender];\r\n        liquidatorRewards[msg.sender] = 0;\r\n        collateralToken.safeTransfer(msg.sender, amount);\r\n        return amount;\r\n    }\r\n}\r\n"
    },
    "contracts/markets/CollaterizedMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"hardhat/console.sol\";\r\nimport \"../accounts/MarketAccounts.sol\";\r\n\r\ncontract CollaterizedMarket is MarketAccounts {\r\n\r\n    mapping(uint256 => uint256) private collateralAmount;\r\n    mapping(uint256 => uint256) private principalAmount;\r\n    \r\n    constructor(string memory name, string memory symbol, string memory uri) MarketAccounts(name, symbol, uri){}\r\n\r\n    function _principalAmount(uint256 accountID) virtual internal view returns(uint){\r\n        return principalAmount[accountID];\r\n    }\r\n\r\n    function _setPrincipalAmount(uint256 accountID, uint256 principal) virtual internal {\r\n        principalAmount[accountID] = principal;\r\n    }\r\n\r\n    function _collateralAmount(uint256 accountID) virtual internal view returns(uint){\r\n        return collateralAmount[accountID];\r\n    }\r\n\r\n    function _setCollateralAmount(uint256 accountID, uint256 collateral) virtual internal {\r\n        collateralAmount[accountID] = collateral;\r\n    }\r\n\r\n}"
    },
    "contracts/markets/CompounInterestMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./OwnableMarket.sol\";\r\nimport \"./interests/CompoundInterest.sol\";\r\n\r\ncontract CompoundInterestMarket is OwnableMarket, CompoundInterest {\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address debtToken,\r\n        address collateralToken,\r\n        string memory baseURI,\r\n        uint liquidationMaxHR,\r\n        uint liquidationPenalty,\r\n        uint closingFee\r\n    ) OwnableMarket (\r\n        priceProviderAddress,\r\n        liquidationThreshold,\r\n        name,\r\n        symbol,\r\n        debtToken,\r\n        collateralToken,\r\n        baseURI,\r\n        liquidationMaxHR,\r\n        liquidationPenalty,\r\n        closingFee\r\n    )  {}\r\n\r\n    function setInterestRate(uint256 _yearlyInterestRate) external onlyAdmin {\r\n        _setInterestRate(_yearlyInterestRate);\r\n    }\r\n\r\n    function _setInterestRate(uint256 _yearlyInterestRate) override(BaseMarket, CompoundInterest) virtual internal {\r\n        CompoundInterest._setInterestRate(_yearlyInterestRate);\r\n    }\r\n\r\n    function _compoundInterest() override(BaseMarket, CompoundInterest) internal {\r\n        CompoundInterest._compoundInterest();\r\n    }\r\n\r\n    function _interestGrace(uint256 principal) override(BaseMarket, CompoundInterest) virtual internal view returns(uint256) {\r\n        return CompoundInterest._interestGrace(principal);\r\n    }\r\n}"
    },
    "contracts/markets/interests/CompoundInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"../../lib/ABDKMath64x64.sol\";\r\n\r\nimport \"./InterestMarket.sol\";\r\n\r\n/// @title Create a vault with compound interest\r\nabstract contract CompoundInterest is InterestModel {\r\n    using ABDKMath64x64 for int128;\r\n\r\n    int128 private interestRate;\r\n    uint256 private gracePeriod;\r\n\r\n    function _setInterestRate(uint256 _yearlyInterestRate) override virtual internal {\r\n        interestRate = ABDKMath64x64.add(\r\n            ABDKMath64x64.divu(\r\n                _yearlyInterestRate,\r\n                10 ** _INTEREST_RATE_DECIMALS() * 365 days\r\n            ),\r\n            ABDKMath64x64.fromUInt(1)\r\n        );\r\n    }\r\n\r\n    function APR() external view returns (uint) {\r\n        uint year = 365 days;\r\n        int128 apr = ABDKMath64x64.mul(interestRate.sub(ABDKMath64x64.fromUInt(1)), ABDKMath64x64.fromUInt(year));\r\n        return ABDKMath64x64.mulu(apr, 10 ** _INTEREST_RATE_DECIMALS());\r\n    }\r\n\r\n    function APY() external view returns (uint){\r\n        uint year = 365 days;\r\n        return ABDKMath64x64.toUInt(interestRate.pow(year).sub(ABDKMath64x64.fromUInt(1)).mul(ABDKMath64x64.fromUInt(10 ** _INTEREST_RATE_DECIMALS())));\r\n    }\r\n\r\n    /// @dev compounds the interest every second and updates the interest index and vault interest index\r\n    /// @notice elapsedSeconds Calculate the elapsed time in seconds since the last update\r\n    function _compoundInterest() override virtual internal {\r\n        //Early return if interestRate has been updates in this block already\r\n        uint256 elapsedSeconds = _elapsedSeconds();\r\n        if (elapsedSeconds == 0) {\r\n            return;\r\n        }\r\n        uint256 roi = ABDKMath64x64.toUInt(\r\n            interestRate.pow(elapsedSeconds).mul(\r\n                ABDKMath64x64.fromUInt(10 ** _INTEREST_RATE_DECIMALS())\r\n            )\r\n        );\r\n        _compoundROI(roi);\r\n    }\r\n\r\n    function _interestGrace(uint256 principal) override virtual internal view returns(uint256) {\r\n        return principal * ABDKMath64x64.mulu(ABDKMath64x64.mul(interestRate, ABDKMath64x64.fromUInt(gracePeriod)), 10 ** _INTEREST_RATE_DECIMALS()) / 10 ** _INTEREST_RATE_DECIMALS();\r\n    }\r\n}"
    },
    "contracts/markets/interests/InterestMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"../CollaterizedMarket.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nabstract contract InterestModel {\r\n    function _setInterestRate(uint256 yearlyInterestRate) virtual internal;\r\n\r\n    function _compoundInterest() virtual internal;\r\n\r\n    function _compoundROI(uint256 _interestYielded) virtual internal;\r\n\r\n    function _elapsedSeconds() virtual internal view returns(uint256);\r\n\r\n    function _INTEREST_RATE_DECIMALS() virtual internal pure returns(uint8);\r\n\r\n    function _interestGrace(uint256 principal) virtual internal view returns(uint256);\r\n}\r\n\r\nabstract contract InterestMarket is CollaterizedMarket, InterestModel {\r\n    uint8 public constant INTEREST_RATE_DECIMALS = 18;\r\n\r\n    uint256 private interestIndex;\r\n    uint256 private lastUpdate; \r\n    mapping(uint256 => uint256) private accountInterestIndex;\r\n\r\n    function getAccountInterestIndex(uint256 accountID) external view returns(uint256) {\r\n        return accountInterestIndex[accountID];\r\n    }\r\n\r\n    constructor(string memory name, string memory symbol, string memory uri) CollaterizedMarket(name, symbol, uri){\r\n        interestIndex = 10 ** INTEREST_RATE_DECIMALS;\r\n        lastUpdate = block.timestamp;\r\n    }\r\n\r\n    function _INTEREST_RATE_DECIMALS() override internal pure returns(uint8){\r\n        return INTEREST_RATE_DECIMALS;\r\n    }\r\n\r\n    function _compoundROI(uint256 _roi) override internal {\r\n        interestIndex = interestIndex * _roi / 10 ** INTEREST_RATE_DECIMALS;\r\n        lastUpdate = block.timestamp;\r\n    }\r\n\r\n    function _interestIndex() internal view returns(uint256) {\r\n        return interestIndex;\r\n    }\r\n\r\n    function _elapsedSeconds() override internal view returns(uint256) {\r\n        return block.timestamp - lastUpdate;\r\n    }\r\n\r\n    function _principalAmount(uint256 _accountID) override internal view returns (uint256) {\r\n        if (accountInterestIndex[_accountID] == 0) {\r\n                return 0;\r\n        }\r\n        return CollaterizedMarket._principalAmount(_accountID) * interestIndex / accountInterestIndex[_accountID];\r\n    }\r\n\r\n    function _increasePrincipalAmount(uint256 accountID, uint256 amount) virtual internal returns (uint){\r\n        uint256 pa = _principalAmount(accountID) + amount;\r\n        _setPrincipalAmount(accountID, pa);\r\n        accountInterestIndex[accountID] = interestIndex;\r\n        return pa;\r\n    }\r\n\r\n    function _decreasePrincipalAmount(uint256 accountID, uint256 amount) virtual internal returns (uint){\r\n        uint256 pa = _principalAmount(accountID);\r\n        uint256 graceInterest = _interestGrace(pa);\r\n        require(pa >= amount, \"Principal repaid is gt outstanding\");\r\n        pa -= amount;\r\n        if (pa <= graceInterest){\r\n            pa = 0;\r\n        }\r\n        _setPrincipalAmount(accountID, pa);\r\n        accountInterestIndex[accountID] = interestIndex;\r\n        return pa;\r\n    }\r\n\r\n    function _increaseCollateralAmount(uint256 accountID, uint256 amount) virtual internal returns(uint){\r\n        uint collateral = _collateralAmount(accountID) + amount;\r\n        _setCollateralAmount(accountID, collateral);\r\n        return collateral;\r\n    }\r\n\r\n    function _decreaseCollateralAmount(uint256 accountID, uint256 amount) virtual internal returns(uint){\r\n        uint collateral = _collateralAmount(accountID);\r\n        require(collateral >= amount, \"Account does not have enough collateral\");\r\n        collateral -= amount;\r\n        _setCollateralAmount(accountID, collateral);\r\n        return collateral;\r\n    }\r\n}"
    },
    "contracts/markets/interests/SimpleInterest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./InterestMarket.sol\";\r\n\r\n/// @title Create a vault with compound interest\r\nabstract contract SimpleInterest is InterestMarket {\r\n\r\n    uint256 private interestRate;\r\n    uint256 private gracePeriod;\r\n\r\n    event InterestAccrued(uint256 interestYield, uint256 timeElapsed);\r\n\r\n    function _setInterestRate(uint256 _yearlyInterestRate) override virtual internal {\r\n        _compoundInterest();\r\n        interestRate =  _yearlyInterestRate / 365 days;\r\n    }\r\n\r\n    function APR() external view returns(uint256) {\r\n        return interestRate * 365 days;\r\n    }\r\n\r\n    function roiSinceCompound() internal view returns(uint256) {\r\n        return _elapsedSeconds() * interestRate + 10 ** _INTEREST_RATE_DECIMALS();\r\n    }\r\n\r\n    /// @dev compounds the interest every second and updates the interest index and vault interest index\r\n    /// @notice elapsedSeconds Calculate the elapsed time in seconds since the last update\r\n    function _compoundInterest() override virtual internal {\r\n        uint256 roi = roiSinceCompound();\r\n        _compoundROI(roi);\r\n        emit InterestAccrued(roi, _elapsedSeconds());\r\n    }\r\n\r\n    function _getGracePeriod() internal view returns(uint256) {\r\n        return gracePeriod;\r\n    }\r\n\r\n    function _setGracePeriod(uint256 grace) internal {\r\n        gracePeriod = grace;\r\n    }\r\n\r\n    function _interestGrace(uint256 principal) override virtual internal view returns(uint256) {\r\n        return principal * interestRate * gracePeriod / 10 ** _INTEREST_RATE_DECIMALS();\r\n    }\r\n}"
    },
    "contracts/markets/LimitedMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./PausableMarket.sol\";\r\nimport \"./OwnableMarket.sol\";\r\n\r\ncontract LimitedMarket is PausableMarket {\r\n    uint256 public dailyIssuanceLimit; //daily issuance limit, which is the maximum amount of debt tokens that the market can issue for borrowing in a day,\r\n    uint256 private dailyIssuanceLeft; // amount of debt tokens that the limited market can still issue for borrowing on that day.\r\n    uint256 public lastIssuanceTime;\r\n    uint256 public constant SECONDS_PER_DAY = 86400;\r\n\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address _debtToken,\r\n        address _collateralToken,\r\n        string memory baseURI,\r\n        uint _liquidationMaxHR,\r\n        uint _liquidationPenalty,\r\n        uint _closingFee\r\n    )\r\n        PausableMarket(\r\n            priceProviderAddress,\r\n            liquidationThreshold,\r\n            name,\r\n            symbol,\r\n            _debtToken,\r\n            _collateralToken,\r\n            baseURI,\r\n            _liquidationMaxHR,\r\n            _liquidationPenalty,\r\n            _closingFee\r\n        )\r\n    {\r\n        lastIssuanceTime = block.timestamp;\r\n    }\r\n\r\n    function getIssuanceLeft() public view returns (uint256) {\r\n        uint256 timeSinceLastIssuance = block.timestamp - lastIssuanceTime;\r\n\r\n        uint256 replenishingRate = dailyIssuanceLimit / SECONDS_PER_DAY;\r\n        uint256 replenishinedAmount = replenishingRate * timeSinceLastIssuance;\r\n        uint256 currentIssuanceLeft = dailyIssuanceLeft + replenishinedAmount;\r\n\r\n        if (currentIssuanceLeft > dailyIssuanceLimit) {\r\n            currentIssuanceLeft = dailyIssuanceLimit;\r\n        }\r\n        return currentIssuanceLeft;\r\n    }\r\n\r\n    function setDailyIssuanceLimit(uint256 newLimit) external onlyAdmin {\r\n        dailyIssuanceLimit = newLimit;\r\n    }\r\n\r\n    function borrow(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) public override virtual {\r\n        uint256 currentIssuanceLeft = getIssuanceLeft();\r\n\r\n        require(\r\n            currentIssuanceLeft >= amount,\r\n            \"Not enough daily issuance left for this borrow amount\"\r\n        );\r\n        dailyIssuanceLeft = currentIssuanceLeft - amount;\r\n\r\n        lastIssuanceTime = block.timestamp;\r\n        super.borrow(accountID, amount);\r\n    }\r\n\r\n    function repay(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) public virtual override {\r\n        uint256 currentIssuanceLeft = getIssuanceLeft();\r\n        uint256 newDailyIssuance = currentIssuanceLeft + amount;\r\n        dailyIssuanceLeft = newDailyIssuance > dailyIssuanceLimit ? dailyIssuanceLimit: dailyIssuanceLeft;\r\n\r\n        super.repay(accountID, amount);\r\n\r\n    }\r\n}\r\n"
    },
    "contracts/markets/OwnableMarket.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"./BaseMarket.sol\";\r\n\r\ncontract OwnableMarket is BaseMarket, AccessControl {\r\n    event AdministratorAdded(address indexed account, address indexed addedBy);\r\n    event AdministratorRemoved(\r\n        address indexed account,\r\n        address indexed removedBy\r\n    );\r\n\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address _debtToken,\r\n        address _collateralToken,\r\n        string memory baseURI,\r\n        uint _liquidationMaxHR,\r\n        uint _liquidationPenalty,\r\n        uint _closingFee\r\n    )\r\n        BaseMarket(\r\n            priceProviderAddress,\r\n            liquidationThreshold,\r\n            name,\r\n            symbol,\r\n            _debtToken,\r\n            _collateralToken,\r\n            baseURI,\r\n            _liquidationMaxHR,\r\n            _liquidationPenalty,\r\n            _closingFee\r\n        )\r\n    {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        treasuryAccountId = 0;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(\r\n            hasRole(DEFAULT_ADMIN_ROLE, msg.sender),\r\n            \"Caller is not an administrator\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setLiquidationPenalty(\r\n        uint256 _liquidationPenalty\r\n    ) external onlyAdmin {\r\n        liquidationPenalty = _liquidationPenalty;\r\n    }\r\n\r\n    function transferToken(\r\n        address to,\r\n        address token,\r\n        uint256 amountToken\r\n    ) external onlyAdmin {\r\n        ERC20(token).transfer(to, amountToken);\r\n    }\r\n\r\n    function changePriceProvider(\r\n        address priceProviderAddress\r\n    ) external onlyAdmin {\r\n        priceProvider = IPriceProvider(priceProviderAddress);\r\n    }\r\n\r\n    function setLiquidationThreshold(\r\n        uint256 _liquidationThreshold\r\n    ) external onlyAdmin {\r\n        liquidationThreshold = _liquidationThreshold;\r\n    }\r\n\r\n    function setClosingFee(uint256 amount) external onlyAdmin {\r\n        closingFee = amount;\r\n    }\r\n\r\n    function setTreasuryAccountId(uint256 _treasury) external onlyAdmin {\r\n        require(_exists(_treasury), \"Vault does not exist\");\r\n        treasuryAccountId = _treasury;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public onlyAdmin {\r\n        _setBaseURI(baseURI);\r\n    }\r\n\r\n    function updateSmallAccountThreshold(\r\n        uint256 _smallAccountThreshold\r\n    ) external override onlyAdmin {\r\n        smallAccountThreshold = _smallAccountThreshold;\r\n    }\r\n\r\n    function addAdmininstrator(address newAdmin) external onlyAdmin {\r\n        grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\r\n        emit AdministratorAdded(newAdmin, msg.sender);\r\n    }\r\n\r\n    function removeAdmininstrator(address admin) external onlyAdmin {\r\n        revokeRole(DEFAULT_ADMIN_ROLE, admin);\r\n        emit AdministratorRemoved(admin, msg.sender);\r\n    }\r\n\r\n    function isAdmin(address account) external view returns (bool) {\r\n        return hasRole(DEFAULT_ADMIN_ROLE, account);\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public virtual view override(ERC721Enumerable, AccessControl) returns (bool) {\r\n        return\r\n            ERC721Enumerable.supportsInterface(interfaceId) ||\r\n            AccessControl.supportsInterface(interfaceId);\r\n    }\r\n}\r\n"
    },
    "contracts/markets/PausableMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"./OwnableMarket.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\ncontract PausableMarket is OwnableMarket, Pausable {\r\n    bytes32 public constant CIRCUIT_BREAKER_ROLE =\r\n        keccak256(\"CIRCUIT_BREAKER_ROLE\");\r\n    event CircuitBreakerAdded(address indexed account, address indexed admin);\r\n    event CircuitBreakerRemoved(address indexed account, address indexed admin);\r\n\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address _debtToken,\r\n        address _collateralToken,\r\n        string memory baseURI,\r\n        uint _liquidationMaxHR,\r\n        uint _liquidationPenalty,\r\n        uint _closingFee\r\n    )\r\n        OwnableMarket(\r\n            priceProviderAddress,\r\n            liquidationThreshold,\r\n            name,\r\n            symbol,\r\n            _debtToken,\r\n            _collateralToken,\r\n            baseURI,\r\n            _liquidationMaxHR,\r\n            _liquidationPenalty,\r\n            _closingFee\r\n        )\r\n    {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setupRole(CIRCUIT_BREAKER_ROLE, msg.sender);\r\n    }\r\n\r\n    function borrow(\r\n        uint256 accountID,\r\n        uint256 amount\r\n    ) public virtual override whenNotPaused {\r\n        super.borrow(accountID, amount);\r\n    }\r\n\r\n    function pause() external onlyAdmin {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyAdmin {\r\n        _unpause();\r\n    }\r\n\r\n    function isPaused() external view returns (bool) {\r\n        return paused();\r\n    }\r\n\r\n    function addCircuitBreaker(address account) external onlyAdmin {\r\n        grantRole(CIRCUIT_BREAKER_ROLE, account);\r\n        emit CircuitBreakerAdded(account, msg.sender);\r\n    }\r\n\r\n    function removeCircuitBreaker(address account) external onlyAdmin {\r\n        revokeRole(CIRCUIT_BREAKER_ROLE, account);\r\n        emit CircuitBreakerRemoved(account, msg.sender);\r\n    }\r\n\r\n    function isCircuitBreaker(address account) external view returns (bool) {\r\n        return hasRole(CIRCUIT_BREAKER_ROLE, account);\r\n    }\r\n\r\n    function triggerCircuitBreaker() external onlyRole(CIRCUIT_BREAKER_ROLE) {\r\n        _pause();\r\n    }\r\n}\r\n"
    },
    "contracts/markets/SimpleInterestMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./LimitedMarket.sol\";\r\nimport \"./interests/SimpleInterest.sol\";\r\n\r\ncontract SimpleInterestMarket is LimitedMarket, SimpleInterest {\r\n    constructor(\r\n        address priceProviderAddress,\r\n        uint256 liquidationThreshold,\r\n        string memory name,\r\n        string memory symbol,\r\n        address debtToken,\r\n        address collateralToken,\r\n        string memory baseURI,\r\n        uint liquidationMaxHR,\r\n        uint liquidationPenalty,\r\n        uint closingFee\r\n    ) LimitedMarket (\r\n        priceProviderAddress,\r\n        liquidationThreshold,\r\n        name,\r\n        symbol,\r\n        debtToken,\r\n        collateralToken,\r\n        baseURI,\r\n        liquidationMaxHR,\r\n        liquidationPenalty,\r\n        closingFee\r\n    )  {}\r\n\r\n    function principalAmount(uint256 accountID) external override view virtual returns(uint256) {\r\n        return InterestMarket._principalAmount(accountID) * roiSinceCompound() / 10**_INTEREST_RATE_DECIMALS();\r\n    }\r\n\r\n    function interestIndex() external view returns(uint256) {\r\n        return _interestIndex() * roiSinceCompound() / 10**_INTEREST_RATE_DECIMALS();\r\n    }\r\n\r\n    function setInterestRate(uint256 _yearlyInterestRate) external onlyAdmin {\r\n        _setInterestRate(_yearlyInterestRate);\r\n    }\r\n\r\n    function _setInterestRate(uint256 _yearlyInterestRate) override(BaseMarket, SimpleInterest) virtual internal {\r\n        SimpleInterest._setInterestRate(_yearlyInterestRate);\r\n    }\r\n\r\n    function _compoundInterest() override(BaseMarket, SimpleInterest) internal {\r\n        SimpleInterest._compoundInterest();\r\n    }\r\n\r\n    function _interestGrace(uint256 principal) override(BaseMarket, SimpleInterest) virtual internal view returns(uint256) {\r\n        return SimpleInterest._interestGrace(principal);\r\n    }\r\n\r\n    function setInterestGracePeriod(uint256 gracePeriod) external onlyAdmin {\r\n        SimpleInterest._setGracePeriod(gracePeriod);\r\n    }\r\n\r\n    function getGracePeriod() external view returns(uint256) {\r\n        return _getGracePeriod();\r\n    }\r\n\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view override(OwnableMarket, ERC721Enumerable) returns (bool) {\r\n        return OwnableMarket.supportsInterface(interfaceId);\r\n    }\r\n}"
    },
    "contracts/mocks/MockAggregatorV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"../oracles/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract MockAggregatorV3 is AggregatorV3Interface {\r\n\r\n    uint80 roundId;\r\n    int256 answer;\r\n    uint256 startedAt;\r\n    uint256 updatedAt;\r\n    uint80 answeredInRound;\r\n\r\n    function setAnswer(\r\n        uint80 _roundId,\r\n        int256 _answer,\r\n        uint256 _startedAt,\r\n        uint256 _updatedAt,\r\n        uint80 _answeredInRound\r\n    ) external {\r\n        roundId = _roundId;\r\n        answer = _answer;\r\n        startedAt = _startedAt;\r\n        updatedAt = _updatedAt;\r\n        answeredInRound = _answeredInRound;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return 8;\r\n    }\r\n\r\n    function description() external view returns (string memory){\r\n        return \"mock aggregator\";\r\n    }\r\n\r\n    function version() external view returns (uint256){\r\n        return 90;\r\n    }\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (uint80, int256, uint256, uint256, uint80) {\r\n        return (_roundId, answer, startedAt, updatedAt, answeredInRound);\r\n    }\r\n\r\n    function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80, int256, uint256, uint256, uint80) {\r\n        return (roundId, answer, startedAt, updatedAt, answeredInRound);\r\n    }\r\n\r\n    function latestAnswer() external view returns (int256){\r\n        return answer;\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/oracles/adapters/balancer/BalancerV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\nimport \"../../interfaces/IBalV2PriceOracle.sol\";\nimport \"../../interfaces/IBPoolV2.sol\";\nimport \"../../interfaces/IBVaultV2.sol\";\n\ncontract BalancerV2PriceOracle is ProviderAwareOracle {\n\n    address public immutable WETH;\n\n    address public vault;\n    uint256 public minimumUpdateInterval = 5 minutes;\n    mapping(address => IPriceOracle) public denominatedOracles; // token => denominated oracle\n    mapping(address => address) public tokenPools; // token => balancer pool\n\n    event SetTokenOracle(\n        address indexed token,\n        address indexed tokenPool,\n        address indexed denominatedOracle\n    );\n\n    /**\n     * @dev sets up the Price Oracle\n     * @param _provider Price provider\n     * @param _vault balancer vault address\n     * @param _minimumUpdateInterval how often to permit updates to the TWAP (seconds)\n     *                               If set to 0, will use the default of 5 minutes\n     */\n    constructor(\n        address _provider,\n        address _vault,\n        address _baseToken,\n        uint256 _minimumUpdateInterval\n    ) ProviderAwareOracle(_provider) {\n        require(_vault != address(0), \"vault cannot be null address\");\n        vault = _vault;\n        if (_minimumUpdateInterval != 0) {\n            minimumUpdateInterval = _minimumUpdateInterval;\n        }\n        WETH = _baseToken;\n    }\n\n    /**\n     * @dev add/update token oracle setting\n     */\n    function setTokenOracle(\n        address _token,\n        address _tokenPool,\n        address _denominatedOracle\n    ) external onlyOwner {\n        bytes32 poolId = IBPoolV2(_tokenPool).getPoolId();\n        (IERC20[] memory tokens, , ) = IBVaultV2(vault).getPoolTokens(poolId);\n\n        require(tokens.length == 2, \"INVALID POOL\");\n        require(\n            _token != WETH &&\n                (_token == address(tokens[0]) || _token == address(tokens[1])),\n            \"INVALID TOKENS\"\n        );\n        require(\n            _denominatedOracle != address(0) ||\n                WETH == address(tokens[0]) ||\n                WETH == address(tokens[1])\n        );\n\n        denominatedOracles[_token] = IPriceOracle(_denominatedOracle);\n        tokenPools[_token] = _tokenPool;\n\n        emit SetTokenOracle(_token, _tokenPool, _denominatedOracle);\n    }\n\n    /****** OPERATIONAL METHODS ******/\n\n    /**\n     * @dev returns the TWAP for the provided pair as of the last update\n     */\n    function getSafePrice(address _token) public view returns (uint256 price) {\n        require(tokenPools[_token] != address(0), \"UNSUPPORTED\");\n\n        IBalV2PriceOracle.OracleAverageQuery[]\n            memory query = new IBalV2PriceOracle.OracleAverageQuery[](1);\n        query[0] = IBalV2PriceOracle.OracleAverageQuery(\n            IBalV2PriceOracle.TWAP_VALUE.PAIR_PRICE,\n            minimumUpdateInterval,\n            10\n        );\n        uint256[] memory prices = IBalV2PriceOracle(tokenPools[_token])\n            .getTimeWeightedAverage(query);\n        uint256 tokenPairPrice = prices[0];\n\n        bytes32 poolId = IBPoolV2(tokenPools[_token]).getPoolId();\n        (IERC20[] memory tokens, , ) = IBVaultV2(vault).getPoolTokens(poolId);\n\n        if (_token == address(tokens[0])) {\n            price =\n                (_getTokenSafePrice(denominatedOracles[_token], tokens[1]) * (10**18)) /\n                tokenPairPrice;\n        } else if (_token == address(tokens[1])) {\n            price =\n                (_getTokenSafePrice(denominatedOracles[_token], tokens[0]) *\n                    tokenPairPrice) /\n                (10**18);\n        }\n    }\n\n    /**\n     * @dev returns the current \"unsafe\" price that can be easily manipulated\n     */\n    function getCurrentPrice(address _token) external view returns (uint256 price) {\n        require(tokenPools[_token] != address(0), \"UNSUPPORTED\");\n\n        bytes32 poolId = IBPoolV2(tokenPools[_token]).getPoolId();\n        uint256[] memory weights = IBPoolV2(tokenPools[_token]).getNormalizedWeights();\n        (IERC20[] memory tokens, uint256[] memory balances, ) = IBVaultV2(vault)\n            .getPoolTokens(poolId);\n\n        if (_token == address(tokens[0])) {\n            price = _tokenPriceFromWeights(\n                tokens[0],\n                tokens[1],\n                balances[0],\n                balances[1],\n                weights[0],\n                weights[1]\n            );\n        } else if (_token == address(tokens[1])) {\n            price = _tokenPriceFromWeights(\n                tokens[1],\n                tokens[0],\n                balances[1],\n                balances[0],\n                weights[1],\n                weights[0]\n            );\n        }\n    }\n\n    /**\n     * @dev updates the TWAP (if enough time has lapsed) and returns the current safe price\n     */\n    function updateSafePrice(address _token) external view returns (uint256) {\n        return getSafePrice(_token);\n    }\n\n    // internal functions\n\n    function _getTokenSafePrice(IPriceOracle oracle, IERC20 token)\n        internal\n        view\n        returns (uint256 price)\n    {\n        if (WETH != address(token)) {\n            price = IPriceOracle(oracle).getSafePrice(address(token));\n        } else {\n            price = PRECISION;\n        }\n    }\n\n    function _getTokenCurrentPrice(IPriceOracle oracle, IERC20 token)\n        internal\n        view\n        returns (uint256 price)\n    {\n        if (WETH != address(token)) {\n            price = IPriceOracle(oracle).getCurrentPrice(address(token));\n        } else {\n            price = PRECISION;\n        }\n    }\n\n    /**\n     * @dev return token price (token0/token1)\n     */\n    function _tokenPriceFromWeights(\n        IERC20 token0,\n        IERC20 token1,\n        uint256 balance0,\n        uint256 balance1,\n        uint256 weight0,\n        uint256 weight1\n    ) internal view returns (uint256) {\n        uint256 pairTokenPrice = _getTokenCurrentPrice(\n            IPriceOracle(denominatedOracles[address(token0)]),\n            token1\n        );\n\n        // price = balance1 / balance0 * weight0 / weight1 * usdPrice1\n\n        // in denominated token price decimals\n        uint256 assetValue = (balance1 * pairTokenPrice) /\n            (10**ERC20(address(token1)).decimals());\n        // in denominated token price decimals\n        // Division via multiplication rather than consecutive division\n        return\n            (assetValue * weight0 * (10**ERC20(address(token0)).decimals())) /\n            (weight1 * balance0);\n    }\n}\n"
    },
    "contracts/oracles/adapters/balancer/BalancerV2WeightedPoolPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@prb/math/src/SD59x18.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\nimport \"../../interfaces/IBPoolV2.sol\";\nimport \"../../interfaces/IBVaultV2.sol\";\n\ncontract BalancerV2WeightedPoolPriceOracle is ProviderAwareOracle {\n    address public immutable WETH;\n\n    IBVaultV2 public vault;\n    uint256 public ratioDiffLimitNumerator;\n    uint256 public ratioDiffLimitDenominator;\n\n    event SetRatioDiffLimit(\n        uint256 ratioDiffLimitNumerator,\n        uint256 ratioDiffLimitDenominator\n    );\n\n    /**\n     * @dev sets up the Price Oracle\n     * @param _provider price provider\n     * @param _vault balancer vault address\n     */\n    constructor(\n        address _provider,\n        address _vault,\n        address _weth\n    ) ProviderAwareOracle(_provider)  {\n        require(_vault != address(0), \"vault cannot be null address\");\n        vault = IBVaultV2(_vault);\n        WETH = _weth;\n    }\n\n    /**\n     * @dev set ratio difference limit\n     */\n    function setRatioDiffLimit(\n        uint256 _ratioDiffLimitNumerator,\n        uint256 _ratioDiffLimitDenominator\n    ) external onlyOwner {\n        require(\n            _ratioDiffLimitNumerator <= _ratioDiffLimitDenominator,\n            \"INVALID RATIO DIFF LIMIT\"\n        );\n\n        ratioDiffLimitNumerator = _ratioDiffLimitNumerator;\n        ratioDiffLimitDenominator = _ratioDiffLimitDenominator;\n\n        emit SetRatioDiffLimit(_ratioDiffLimitNumerator, _ratioDiffLimitDenominator);\n    }\n\n    /****** OPERATIONAL METHODS ******/\n\n    /**\n     * @dev returns the TWAP for the provided pair as of the last update\n     */\n    function getSafePrice(address _bpt) public view returns (uint256) {\n        return _getLPPrice(_bpt, true);\n    }\n\n    /**\n     * @dev returns the current \"unsafe\" price that can be easily manipulated\n     */\n    function getCurrentPrice(address _bpt) external view returns (uint256) {\n        return _getLPPrice(_bpt, false);\n    }\n\n    /**\n     * @dev updates the TWAP (if enough time has lapsed) and returns the current safe price\n     */\n    function updateSafePrice(address _bpt) external view returns (uint256) {\n        return getSafePrice(_bpt);\n    }\n\n    // internal functions\n\n    function _getTokenSafePrice(address token) internal view returns (uint256 price) {       \n        if (token != WETH) {\n            price = provider.getSafePrice(token);\n        } else {\n            price = PRECISION;\n        }\n    }\n\n    function _getTokenCurrentPrice(address token) internal view returns (uint256 price) {\n        if (token != WETH) {\n            price = provider.getCurrentPrice(token);\n        } else {\n            price = PRECISION;\n        }\n    }\n\n    function _getLPPrice(address _bpt, bool isSafePrice)\n        internal\n        view\n        returns (uint256 price)\n    {\n        bytes32 poolId = IBPoolV2(_bpt).getPoolId();\n        uint256[] memory weights = IBPoolV2(_bpt).getNormalizedWeights();\n        int256 totalSupply = int256(IBPoolV2(_bpt).totalSupply());\n        (IERC20[] memory tokens, uint256[] memory balances, ) = vault.getPoolTokens(\n            poolId\n        );\n\n        SD59x18 totalPi = sd(1e18);\n\n        uint256[] memory prices = new uint256[](tokens.length);\n        // update balances in 18 decimals\n        for (uint256 i = 0; i < tokens.length; i++) {\n            balances[i] =\n                (balances[i] * (10**18)) /\n                (10**ERC20(address(tokens[i])).decimals());\n            prices[i] = isSafePrice\n                ? _getTokenSafePrice(address(tokens[i]))\n                : _getTokenCurrentPrice(address(tokens[i]));\n\n            SD59x18 val = div(sd(int256(prices[i])), sd(int256(weights[i])));\n            SD59x18 indivPi = pow(val, sd(int256(weights[i])));\n\n            totalPi = totalPi.mul(indivPi);\n           \n        }\n\n        int256 invariant = int256(IBPoolV2(_bpt).getLastInvariant());\n        SD59x18 numerator = mul(totalPi, sd(invariant));\n\n        price = uint256(unwrap(div(numerator, sd(totalSupply))));\n    }\n\n    function _checkRatio(\n        uint256 reserve0,\n        uint256 reserve1,\n        uint256 price0,\n        uint256 price1\n    ) internal view {\n        uint256 value0 = reserve0 * price0;\n        uint256 value1 = reserve1 * price1;\n        uint256 diffLimit = (value0 * ratioDiffLimitNumerator) /\n            ratioDiffLimitDenominator;\n\n        require(\n            value1 < value0 + diffLimit && value0 < value1 + diffLimit,\n            \"INVALID RATIO\"\n        );\n    }\n}\n"
    },
    "contracts/oracles/adapters/chainlink/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"../ProviderAwareOracle.sol\";\r\n\r\ncontract ChainlinkPriceOracle is ProviderAwareOracle {\r\n\r\n    uint private constant MIN_TIME = 60 minutes;\r\n    \r\n    // If comparing to WETH, will be left as address(0)\r\n    address public BASE_PRICE_FEED;\r\n\r\n    mapping(address => address) public priceFeed; // token => chainlink price feed\r\n\r\n    event UpdateValues(address indexed feed);\r\n    event OutputDecimalsUpdated(uint8 _old, uint8 _new);\r\n    event SetPriceFeed(address indexed token, address indexed feed);\r\n\r\n    constructor(address _provider, address _base_price_feed) ProviderAwareOracle(_provider) {\r\n        BASE_PRICE_FEED = _base_price_feed;\r\n    }\r\n\r\n    function setPriceFeed(address _token, address _feed) external onlyOwner {\r\n        priceFeed[_token] = _feed;\r\n\r\n        emit SetPriceFeed(_token, _feed);\r\n    }\r\n\r\n    function getSafePrice(address _token) public view returns (uint256 _amountOut) {\r\n        return getCurrentPrice(_token);\r\n    }\r\n\r\n    function getCurrentPrice(address _token) public view returns (uint256 _amountOut) {\r\n        require(priceFeed[_token] != address(0), \"UNSUPPORTED\");\r\n        if (BASE_PRICE_FEED == address(0)) {\r\n            uint256 feedDecimals = AggregatorV3Interface(priceFeed[_token]).decimals();\r\n            return _feedPrice(priceFeed[_token]) * (10**(PRECISION - feedDecimals));\r\n        }\r\n        return _divide(\r\n            _feedPrice(priceFeed[_token]),\r\n            _feedPrice(BASE_PRICE_FEED),\r\n            PRECISION\r\n        );\r\n    }\r\n\r\n    function updateSafePrice(address _feed) public returns (uint256 _amountOut) {\r\n        emit UpdateValues(_feed); // keeps this mutable so it matches the interface\r\n\r\n        return getCurrentPrice(_feed);\r\n    }\r\n\r\n    /****** INTERNAL METHODS ******/\r\n\r\n    /**\r\n     * @dev internal method that does quick division using the set precision\r\n     */\r\n    function _divide(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint8 precision\r\n    ) internal pure returns (uint256) {\r\n        return (a * (10**precision)) / b;\r\n    }\r\n\r\n    function _feedPrice(address _feed) internal view returns (uint256 latestUSD) {\r\n\r\n        /// To allow for TOKEN-ETH feeds on one oracle, TOKEN-USD feeds on another\r\n        if(_feed == address(0)) {\r\n            return PRECISION;\r\n        }\r\n\r\n        (uint80 roundID, int256 answer, uint256 startedAt, uint256 timestamp, uint80 answeredInRound) = AggregatorV3Interface(_feed).latestRoundData();\r\n\r\n        require(answer > 0, 'ER045');\r\n        require(timestamp != 0, 'ER046');\r\n        require(answeredInRound >= roundID, \"ER047\");\r\n\r\n        // difference between when started and returned needs to be less than 60-minutes\r\n        require(timestamp - startedAt < MIN_TIME, \"E113\");\r\n\r\n        return uint256(answer);\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/adapters/curve/CurveLPOracle-VULNERABLE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\nimport \"../../interfaces/CurveTokenInterface.sol\";\nimport \"../../../lib/FixedPointMathLib.sol\";\n\n/**\n * This contract can be exploited if no protection is in place\n * get_virtual_price() function can be manipulated\n * https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/\n */\n\ncontract VULNERABLECurveLPOracle is ProviderAwareOracle {\n\n    using FixedPointMathLib for uint;\n\n    /// @notice Curve token version, currently support v1, v2 and v3\n    enum CurveTokenVersion {\n        V1,\n        V2,\n        V3\n    }\n\n    /// @notice Curve pool type, currently support ETH and USD base\n    enum CurvePoolType {\n        ETH,\n        USD\n    }\n\n    struct CrvTokenInfo {\n        /// @notice Check if this token is a curve pool token\n        bool isCrvToken;\n        /// @notice The curve pool type\n        CurvePoolType poolType;\n        /// @notice The curve swap contract address\n        address curveSwap;\n        uint nCoins;\n    }\n\n    event SetCurveToken(address token, CurvePoolType poolType, address swap, uint numberTokens);\n\n    /// @notice Curve pool token data\n    mapping(address => CrvTokenInfo) public crvTokens;\n\n    address private immutable USDC;\n\n    constructor(address _provider, address _usdc) ProviderAwareOracle(_provider) {\n        USDC = _usdc;\n    }\n\n    function getSafePrice(address token) external view override returns (uint256 _amountOut) {\n        _amountOut = getCrvTokenPrice(token);\n    }\n\n    /// @dev This method has no guarantee on the safety of the price returned. It should only be\n    //used if the price returned does not expose the caller contract to flashloan attacks.\n    function getCurrentPrice(address token) external view override returns (uint256 _amountOut) {\n        _amountOut = getCrvTokenPrice(token);\n    }\n\n    /// @dev Gets the safe price, no updates necessary\n    function updateSafePrice(address token) external view override returns (uint256 _amountOut) {\n        _amountOut = getCrvTokenPrice(token);\n    }\n\n    /**\n     * @notice Get price for curve pool tokens\n     * @param token The curve pool token\n     * @return The price\n     */\n    function getCrvTokenPrice(address token) internal view returns (uint256) {\n        CrvTokenInfo memory crvTokenInfo = crvTokens[token];\n        require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n\n        uint256 virtualPrice = CurveSwapInterface(crvTokenInfo.curveSwap).get_virtual_price();\n\n        if (crvTokenInfo.poolType == CurvePoolType.ETH) {\n            return virtualPrice;\n        }\n\n        // We treat USDC as USD and convert the price to ETH base.\n        return  provider.getSafePrice(USDC) * virtualPrice / PRECISION;\n    }\n\n    /**\n     * @notice See assets as curve pool tokens for multiple tokens\n     * @param tokenAddresses The list of tokens\n     * @param poolType The list of curve pool type (ETH or USD base only)\n     * @param swap The list of curve swap address\n     */\n    function setCurveTokens(\n        address[] calldata tokenAddresses,\n        CurveTokenVersion[] calldata version,\n        CurvePoolType[] calldata poolType,\n        address[] calldata swap,\n        uint[] calldata nTokens\n    ) external onlyOwner {\n        require(\n            tokenAddresses.length == version.length &&\n                tokenAddresses.length == poolType.length &&\n                tokenAddresses.length == swap.length,\n            \"mismatched data\"\n        );\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            if (version[i] == CurveTokenVersion.V3) {\n                // Sanity check to make sure the token minter is right.\n                require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n            }\n\n            crvTokens[tokenAddresses[i]] = CrvTokenInfo({isCrvToken: true, poolType: poolType[i], curveSwap: swap[i],  nCoins: nTokens[i]});\n            emit SetCurveToken(tokenAddresses[i], poolType[i], swap[i], nTokens[i]);\n        }\n    }\n\n}"
    },
    "contracts/oracles/adapters/ProviderAwareOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../../interfaces/IPriceOracle.sol\";\r\nimport \"../../interfaces/IPriceProvider.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nabstract contract ProviderAwareOracle is IPriceOracle, Ownable {\r\n\r\n    uint8 internal immutable PRECISION;\r\n\r\n    IPriceProvider public provider;\r\n\r\n    event ProviderTransfer(address _newProvider, address _oldProvider);\r\n\r\n    constructor(address _provider) {\r\n        provider = IPriceProvider(_provider);\r\n        PRECISION = provider.DECIMALS();\r\n    }\r\n\r\n    function setPriceProvider(address _newProvider) external onlyOwner {\r\n        address oldProvider = address(provider);\r\n        provider = IPriceProvider(_newProvider);\r\n        emit ProviderTransfer(_newProvider, oldProvider);\r\n    }\r\n\r\n\r\n}\r\n"
    },
    "contracts/oracles/adapters/SimpleOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ProviderAwareOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SimpleOracle is ProviderAwareOracle {\n\n    mapping(address => mapping(address => bool)) public tokenAdmins;\n\n    mapping(address => uint) private _currentPrices;\n\n    event PriceUpdated(address indexed token, uint indexed price);\n    event AdminStatusApproved(address indexed token, address indexed admin, bool indexed isApproved);\n\n    modifier onlyAdmin(address token) {\n        require(msg.sender == owner() || tokenAdmins[token][msg.sender], 'Unauthorized!');\n        _;\n    }\n\n    constructor(address _provider) ProviderAwareOracle(_provider) {}\n\n    function getSafePrice(address token) external view returns (uint256 _amountOut) {\n        return _currentPrices[token];\n    }\n\n    /// @dev This method has no guarantee on the safety of the price returned. It should only be\n    //used if the price returned does not expose the caller contract to flashloan attacks.\n    function getCurrentPrice(address token) external view returns (uint256 _amountOut) {\n        return _currentPrices[token];\n    }\n\n    /// @dev This method returns a flashloan resistant price, but doesn't\n    //have the view modifier which makes it convenient to update\n    //a uniswap oracle which needs to maintain the TWAP regularly.\n    //You can use this function while doing other state changing tx and\n    //make the callers maintain the oracle.\n    function updateSafePrice(address token) external view returns (uint256 _amountOut) {\n        return _currentPrices[token];\n    }\n\n    function updatePrice(address token, uint price) external onlyAdmin(token) {\n        _currentPrices[token] = price;\n        emit PriceUpdated(token, price);\n    }\n\n    function setAdminStatus(address token, address admin, bool isApproved) external onlyOwner {\n        tokenAdmins[token][admin] = isApproved;\n        emit AdminStatusApproved(token, admin, isApproved);\n    }\n\n\n}\n"
    },
    "contracts/oracles/adapters/stader/sFTMxOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport \"../ProviderAwareOracle.sol\";\n\ninterface IFTMStaking {\n    function getExchangeRate() external view returns (uint256);\n}\n\n/**\n * @author 0xTinder for Revest Finance\n * Simple sFTMx oracle to return the price of sFTMx in terms of WETH. References the\n * exchange rate tracked in the FTMStaking contract found:\n * https://ftmscan.deth.net/address/0xB458BfC855ab504a8a327720FcEF98886065529b#readProxyContract\n */\ncontract sFTMxOracle is ProviderAwareOracle {\n    address wFTM;\n    IFTMStaking FTMStaking;\n    /**\n     * @param _provider address of the Revest PriceProvider\n     * @param _wFTM address of WFTM\n     * @param _FTMStaking address of the sFTMx staking contract\n     */\n    constructor(address _provider, address _wFTM, address _FTMStaking)\n        ProviderAwareOracle(_provider)\n    {\n        wFTM = _wFTM;\n        FTMStaking = IFTMStaking(_FTMStaking);\n    }\n    /**\n     * @notice get the flashloan resistant price for sFTMx\n     * @param \"\" included for interface compliance\n     * @return _amountOut the sFTMx/WETH exchange rate\n     */\n    function getSafePrice(address) public view returns (uint256 _amountOut) {\n        // get the current price of wFTM\n        uint256 ftmPrice = provider.getSafePrice(wFTM);\n\n        // get the current xrate\n        uint256 xrate = FTMStaking.getExchangeRate();\n\n        return ftmPrice * xrate / 1e18;\n    }\n    /**\n     * @notice get the current price for sFTMx\n     * @param \"\" included for interface compliance\n     * @return _amountOut the sFTMx/WETH exchange rate\n     * @dev `getSafePrice` and `getCurrentPrice` differ only by their call to priceProvider,\n     * however in prod only getSafePrice is used.\n     */\n    function getCurrentPrice(address)\n        public\n        view\n        returns (uint256 _amountOut)\n    {\n        // get the current price of wFTM\n        uint256 ftmPrice = provider.getCurrentPrice(wFTM);\n\n        // get the current xrate\n        uint256 xrate = FTMStaking.getExchangeRate();\n\n        return ftmPrice * xrate / 1e18;\n    }\n\n    /// @dev this isn't relevant for chainlink based oracles\n    function updateSafePrice(address token)\n        external\n        view\n        returns (uint256 _amountOut)\n    {\n        return getCurrentPrice(token);\n    }\n}"
    },
    "contracts/oracles/adapters/uniswapV2/UniswapV2LPPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\nimport \"../../../lib/FixedPointMathLib.sol\";\n\n\ncontract UniswapV2LPPriceOracle is ProviderAwareOracle {\n    \n    using FixedPointMathLib for uint;\n\n    /**\n     * @dev sets up the Price Oracle\n     */\n    constructor(address _provider) ProviderAwareOracle(_provider) {\n        \n    }\n\n    \n    /****** OPERATIONAL METHODS ******/\n\n    /**\n     * @dev returns the TWAP for the provided pair as of the last update\n     */\n    function getSafePrice(address _lpToken) public view returns (uint) {\n        return _getLPPrice(_lpToken, true);\n    }\n\n    /**\n     * @dev returns the current \"unsafe\" price that can be easily manipulated\n     */\n    function getCurrentPrice(address _lpToken) external view returns (uint) {\n        return _getLPPrice(_lpToken, false);\n    }\n\n    /**\n     * @dev updates the TWAP (if enough time has lapsed) and returns the current safe price\n     */\n    function updateSafePrice(address _lpToken) external view returns (uint) {\n        return getSafePrice(_lpToken);\n    }\n\n    // internal functions\n\n    function _getLPPrice(address pair, bool isSafePrice) internal view returns (uint price) {\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        uint totalSupply = IUniswapV2Pair(pair).totalSupply();\n        (uint r0, uint r1, ) = IUniswapV2Pair(pair).getReserves();\n        uint8 dec0 = IERC20Metadata(token0).decimals();\n        uint8 dec1 = IERC20Metadata(token1).decimals();\n        uint sqrtR = (r0*r1 * (10 ** (36-dec0-dec1))).sqrt();\n        \n        uint p0 = isSafePrice ? provider.getSafePrice(token0) : provider.getCurrentPrice(token0);\n        uint p1 = isSafePrice ? provider.getSafePrice(token1) : provider.getCurrentPrice(token1);\n        uint sqrtP = (p0*p1).sqrt();\n        price =(2*sqrtR*sqrtP) / totalSupply; // in 1E18 precision\n    }\n}\n"
    },
    "contracts/oracles/adapters/uniswapV2/UniswapV2TWAPOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../lib/FixedPoint.sol\";\nimport \"../../../lib/uniswap/IUniswapV2Factory.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\n\n/**\nSee https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\nfor the basis for the below contract. ExampleOracleSimple contract has been extended to support tracking multiple\npairs within the same contract.\n*/\n\ncontract UniswapV2TWAPOracle is ProviderAwareOracle {\n    using FixedPoint for *;\n\n    struct TwapConfig {\n        uint lastUpdateCumulativePrice;\n        uint32 timestampLatest; // 4 bytes\n        FixedPoint.uq112x112 lastUpdateTwapPrice; // 28 bytes\n        // Should conform to IUniswapV2Pair interface\n        address pairAddress; // 20 bytes\n        bool isToken0; // 1 byte\n        uint8 decimals; // 1 byte\n        uint32 lastTimeTwapPoked;\n    }\n\n    /// The commonly-used asset tokens on this TWAP are paired with\n    /// May be token0 or token1 depending on sort order\n    address public immutable TOKEN;\n\n    address public immutable WETH;\n\n    // Maps token0 to it's latest readings\n    mapping(address => TwapConfig) public twaps;\n\n    // 5 minutes\n    uint32 public constant MIN_UPDATE_DEFAULT = 5 minutes;\n    uint32 public constant MAX_UPDATE = 60 minutes;\n\n    uint32 public immutable MIN_UPDATE;\n\n    address public uniswap;\n\n    /**\n     * @dev sets up the Price Oracle\n     *\n     * @param _inToken the pool token which will be a common component for all govi tokens on this TWAP\n     * @param _weth the WETH address for the given chain\n     * @param _minimumUpdateInterval how often to permit updates to the TWAP (seconds)\n     *                               If set to 0, will use the default of 5 minutes\n     * @param _factory the address of the uniswap factory (NOT THE ROUTER) to retrieve pairs from\n     */\n    constructor(address _provider, address _inToken, address _weth, uint32 _minimumUpdateInterval, address _factory) ProviderAwareOracle(_provider) {\n        require(_inToken != address(0) && _weth != address(0), \"ER003\");\n        MIN_UPDATE = _minimumUpdateInterval == 0 ? MIN_UPDATE_DEFAULT : _minimumUpdateInterval;\n        TOKEN = _inToken;\n        WETH = _weth;\n        uniswap = _factory;\n    }\n\n    /****** OPERATIONAL METHODS ******/\n\n    /**\n     * @dev returns the TWAP for the provided pair as of the last update\n     */\n    function getSafePrice(address asset) public view returns (uint256 amountOut) {\n        require(block.timestamp - twaps[asset].lastTimeTwapPoked <= MAX_UPDATE, 'ER037');\n        TwapConfig memory twap = twaps[asset];\n        amountOut = _convertPrice(asset, twap.lastUpdateTwapPrice);\n    }\n\n    /**\n     * @dev returns the current \"unsafe\" price that can be easily manipulated\n     */\n    function getCurrentPrice(address asset) public view returns (uint256 amountOut) {\n        TwapConfig memory twap = twaps[asset];\n        IUniswapV2Pair pair = IUniswapV2Pair(twap.pairAddress);\n\n        uint8 decimals;\n\n        try IERC20Metadata(asset).decimals() returns (uint8 numDecimals) {\n            decimals = numDecimals;\n        } catch {\n            decimals = 18;\n        }\n\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\n      \n        uint8 _token1MissingDecimals;\n        if (twap.isToken0) {\n            if (decimals > IERC20Metadata(TOKEN).decimals()) {\n                _token1MissingDecimals = decimals - (IERC20Metadata(TOKEN).decimals());\n                amountOut = (reserve1 * (10**_token1MissingDecimals) * PRECISION) / reserve0;\n            } else {\n\n                _token1MissingDecimals = (IERC20Metadata(TOKEN).decimals()) - decimals;\n                amountOut = (reserve1 * PRECISION) / (reserve0 * (10**_token1MissingDecimals));\n            }    \n        } else {\n            if (decimals > IERC20Metadata(TOKEN).decimals()) {\n                _token1MissingDecimals = decimals - (IERC20Metadata(TOKEN).decimals());\n                amountOut = (reserve0 * (10**_token1MissingDecimals) * PRECISION) / reserve1;\n\n            } else {\n                _token1MissingDecimals = (IERC20Metadata(TOKEN).decimals()) - decimals;\n                        // amountOut = (reserve0 * (10**_token1MissingDecimals) * PRECISION) / reserve1;\n                amountOut = (reserve0 * PRECISION) / (reserve1 * (10**_token1MissingDecimals));\n\n            }    \n        }\n        \n        if(TOKEN != WETH) {\n            amountOut = amountOut * provider.getSafePrice(TOKEN) / PRECISION;\n        }\n    }\n\n    /**\n     * @dev updates the TWAP (if enough time has lapsed) and returns the current safe price\n     */\n    function updateSafePrice(address asset) public returns (uint256 amountOut) {\n        // This method will fail if the TWAP has not been initialized on this contract\n        // This action must be performed externally\n        (uint cumulativeLast, uint lastCumPrice, uint32 lastTimeSync, uint32 lastTimeUpdate) = _fetchParameters(asset);\n        TwapConfig storage twap = twaps[asset];\n        FixedPoint.uq112x112 memory lastAverage;\n        lastAverage = FixedPoint.uq112x112(uint224((cumulativeLast - lastCumPrice) / (lastTimeSync - lastTimeUpdate)));\n        if(lastTimeSync > lastTimeUpdate) {\n            twap.lastUpdateTwapPrice = lastAverage;\n            twap.lastUpdateCumulativePrice = cumulativeLast;\n            twap.timestampLatest = lastTimeSync;\n        }   \n        twap.lastTimeTwapPoked = uint32(block.timestamp);\n\n        // Call sub method HERE to same thing getSafePrice uses to avoid extra SLOAD\n        amountOut = _convertPrice(asset, lastAverage);\n    }\n\n    /****** INTERNAL METHODS ******/\n\n    function _convertPrice(address asset, FixedPoint.uq112x112 memory lastUpdatePrice) private view returns (uint amountOut) {\n        uint nativeDecimals = 10**IERC20Metadata(asset).decimals();\n        \n        // calculate the value based upon the average cumulative prices\n        // over the time period (TWAP)\n        if (TOKEN == WETH) {\n            // No need to convert the asset\n            amountOut = lastUpdatePrice.mul(nativeDecimals).decode144();\n        } else {\n            // Need to convert the feed to be in terms of ETH\n            uint8 tokenDecimals = IERC20Metadata(TOKEN).decimals();\n            uint conversion = provider.getSafePrice(TOKEN);\n            // amountOut = FixedPoint.uq112x112(uint112(lastUpdatePrice.mul(uint144(10**tokenDecimals)).decode144())).div(nativeDecimals).decode();\n            amountOut = lastUpdatePrice.mul(10**tokenDecimals).decode144() * conversion / nativeDecimals;\n        }\n    }\n\n    function _fetchParameters(\n        address asset\n    ) private view returns (\n        uint cumulativeLast, \n        uint lastCumPrice, \n        uint32 lastTimeSync, \n        uint32 lastTimeUpdate\n    ) {    \n        TwapConfig memory twap = twaps[asset];\n        require(twap.decimals > 0, 'ER035');\n        // Enforce passage of a safe amount of time\n        lastTimeUpdate = twap.timestampLatest;\n        require(block.timestamp > twap.lastTimeTwapPoked + MIN_UPDATE, 'ER036');\n        IUniswapV2Pair pair = IUniswapV2Pair(twap.pairAddress);\n        cumulativeLast = twap.isToken0 ? pair.price0CumulativeLast() : pair.price1CumulativeLast();\n        lastCumPrice = twap.lastUpdateCumulativePrice;\n        (, , lastTimeSync) = pair.getReserves();\n    }\n\n    /**\n    * @dev Setup the twap for a new token to pair it to\n    * @param asset token to initialize a twap for that is paired with TOKEN (WETH) \n    */\n    function initializeOracle(address asset) external {\n        require(asset != address(0), 'ER003');\n        require(twaps[asset].decimals == 0, 'ER038');\n\n        // Resolve Uniswap pair sorting order\n        address token1 = asset < TOKEN ? TOKEN : asset;\n        bool isToken0 = token1 != asset;\n        address token0 = isToken0 ? asset : TOKEN;\n\n        address pair = IUniswapV2Factory(uniswap).getPair(token0, token1);\n        require(pair != address(0), 'ER003');\n        IUniswapV2Pair uni_pair = IUniswapV2Pair(pair);        \n        TwapConfig memory twap = TwapConfig(\n            isToken0 ? uni_pair.price0CumulativeLast() : uni_pair.price1CumulativeLast(), \n            0,\n            FixedPoint.uq112x112(0),\n            pair, \n            isToken0, \n            IERC20Metadata(asset).decimals(),\n            uint32(block.timestamp)\n        );\n        (, , twap.timestampLatest) = uni_pair.getReserves();\n        twaps[asset] = twap;\n    }\n}\n"
    },
    "contracts/oracles/adapters/velodrome/VelodromeTWAP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../ProviderAwareOracle.sol\";\nimport \"../../interfaces/IPairFactory.sol\";\nimport \"../../interfaces/IPair.sol\";\n\n\n\ncontract VelodromeTWAP is ProviderAwareOracle {\n\n    struct TwapConfig {\n        address pairAddress; \n        uint8 decimals; \n    }\n\n    /// The commonly-used asset tokens on this TWAP are paired with\n    /// May be token0 or token1 depending on sort order\n    address public immutable TOKEN;\n\n    /// Address for the WETH token on this chain, needed for conformity\n    address public immutable WETH;\n\n    /// Stores # of decimals for TOKEN\n    uint8 public immutable TOKEN_DECIMALS;\n\n    // Maps non-base token to pair address\n    mapping(address => TwapConfig) public twaps;\n\n    address public velodrome;\n\n    /**\n     * @dev sets up the Price Oracle\n     *\n     * @param _inToken the pool token which will be a common component for all govi tokens on this TWAP\n     * @param _weth the WETH address for the given chain\n     * @param _factory the address of the uniswap factory (NOT THE ROUTER) to retrieve pairs from\n     */\n    constructor(address _provider, address _inToken, address _weth, address _factory) ProviderAwareOracle(_provider) {\n        require(_inToken != address(0) && _weth != address(0), \"ER003\");\n        TOKEN = _inToken;\n        WETH = _weth;\n        TOKEN_DECIMALS = IERC20Metadata(TOKEN).decimals();\n        velodrome = _factory;\n    }\n\n    /****** OPERATIONAL METHODS ******/\n\n    /**\n     * @dev returns the TWAP for the provided pair as of the last update\n     */\n    function getSafePrice(address asset) external view returns (uint256 amountOut) {\n        amountOut = _fetchPrice(asset);\n    }\n\n    /**\n     * @dev returns the current \"unsafe\" price that can be easily manipulated\n     */\n    function getCurrentPrice(address asset) external view returns (uint256 amountOut) {\n        amountOut = _fetchPrice(asset);\n    }\n\n    /**\n     * @dev updates the TWAP (if enough time has lapsed) and returns the current safe price\n     */\n    function updateSafePrice(address asset) external view returns (uint256 amountOut) {\n        amountOut = _fetchPrice(asset);\n    }\n\n    /****** INTERNAL METHODS ******/\n\n    function _fetchPrice(address asset) private view returns (uint amountOut) {\n        TwapConfig memory twap = twaps[asset];\n        IPair pair = IPair(twap.pairAddress);\n\n        uint8 decimals = twap.decimals; // 18\n\n        if (decimals > TOKEN_DECIMALS) {\n            uint _tokenMissingDecimals = decimals - TOKEN_DECIMALS; // 12\n            amountOut = pair.current(asset, PRECISION) * (10**_tokenMissingDecimals);\n        } else {\n            uint _tokenMissingDecimals = TOKEN_DECIMALS - decimals;\n            amountOut = pair.current(asset, PRECISION) / (10**_tokenMissingDecimals);\n        }   \n\n        if(TOKEN != WETH) {\n            amountOut = amountOut * provider.getSafePrice(TOKEN) / PRECISION;\n        }\n    }\n\n    /**\n    * @dev Setup the twap for a new token to pair it to\n    * @param asset token to initialize a twap for that is paired with TOKEN (WETH) \n    */\n    function initializeOracle(address asset, bool isStable) external {\n        require(asset != address(0), 'ER003');\n        require(twaps[asset].pairAddress == address(0), 'ER038');\n\n        // Resolve pair sorting order\n        address token1 = asset < TOKEN ? TOKEN : asset;\n        bool isToken0 = token1 != asset;\n        address token0 = isToken0 ? asset : TOKEN;\n\n        address pair = IPairFactory(velodrome).getPair(token0, token1, isStable);\n        require(pair != address(0), 'ER003');\n        TwapConfig memory twap = TwapConfig(pair, IERC20Metadata(asset).decimals());\n        twaps[asset] = twap;\n    }\n}\n"
    },
    "contracts/oracles/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.5;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestAnswer() external view returns (int256);\n}\n"
    },
    "contracts/oracles/interfaces/CurveTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface CurveTokenV3Interface {\n    function minter() external view returns (address);\n}\n\ninterface CurveSwapInterface {\n    function get_virtual_price() external view returns (uint256);\n}\n"
    },
    "contracts/oracles/interfaces/IBalV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.5;\n\ninterface IBalV2PriceOracle {\n    // The three values that can be queried:\n    //\n    // - PAIR_PRICE: the price of the tokens in the Pool, expressed as the price of the second token in units of the\n    //   first token. For example, if token A is worth $2, and token B is worth $4, the pair price will be 2.0.\n    //   Note that the price is computed *including* the tokens decimals. This means that the pair price of a Pool with\n    //   DAI and USDC will be close to 1.0, despite DAI having 18 decimals and USDC 6.\n    //\n    // - BPT_PRICE: the price of the Pool share token (BPT), in units of the first token.\n    //   Note that the price is computed *including* the tokens decimals. This means that the BPT price of a Pool with\n    //   USDC in which BPT is worth $5 will be 5.0, despite the BPT having 18 decimals and USDC 6.\n    //\n    // - INVARIANT: the value of the Pool's invariant, which serves as a measure of its liquidity.\n    enum TWAP_VALUE {\n        PAIR_PRICE,\n        BPT_PRICE,\n        INVARIANT\n    }\n\n    struct OracleAverageQuery {\n        TWAP_VALUE variable;\n        uint256 secs;\n        uint256 ago;\n    }\n\n    /**\n     * @dev Returns the time average weighted price corresponding to each of `queries`. Prices are represented as 18\n     * decimal fixed point values.\n     */\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n        external\n        view\n        returns (uint256[] memory results);\n\n    /**\n     * @dev Returns latest sample of `variable`. Prices are represented as 18 decimal fixed point values.\n     */\n    function getLatest(TWAP_VALUE variable) external view returns (uint256);\n}\n"
    },
    "contracts/oracles/interfaces/IBPoolV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.12;\n\ninterface IBPoolV2 {\n    function getNormalizedWeights() external view returns (uint256[] memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function getPoolId() external view returns (bytes32);\n\n    function getLastInvariant() external view returns (uint256);\n}"
    },
    "contracts/oracles/interfaces/IBVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBVaultV2 {\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n}"
    },
    "contracts/oracles/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPair {\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\n    function claimFees() external returns (uint, uint);\n    function tokens() external returns (address, address);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n    function current(address tokenIn, uint amountIn) external view returns (uint amountOut);\n}\n"
    },
    "contracts/oracles/interfaces/IPairFactory.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IPairFactory {\n    function allPairsLength() external view returns (uint);\n    function isPair(address pair) external view returns (bool);\n    function pairCodeHash() external pure returns (bytes32);\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}